<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://kauri.io/single/how-to-create-an-ethereum-wallet-address-from-a-p/">
    <link rel="shortcut icon" href="../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>How to create an Ethereum wallet address from a private key - kauri.io</title>
    <link href="../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../js/jquery-3.2.1.min.js"></script>
    <script src="../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "How to create an Ethereum wallet address from a private key", url: "#_top", children: [
              {title: "Public key", url: "#public-key" },
              {title: "Wallet address", url: "#wallet-address" },
              {title: "Checksum", url: "#checksum" },
              {title: "Conclusion", url: "#conclusion" },
          ]},
        ];

    </script>
    <script src="../../js/base.js"></script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-172017815-1', 'kauri.io');
        ga('send', 'pageview');
    </script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    <h1 id="how-to-create-an-ethereum-wallet-address-from-a-private-key">How to create an Ethereum wallet address from a private key<a class="headerlink" href="#how-to-create-an-ethereum-wallet-address-from-a-private-key" title="Permanent link"></a></h1>
<hr />
<p><img alt="" src="https://ipfs.infura.io/ipfs/QmPjsFF2FDEQc8fqQBG4rMUsMCaXmHgigUhgKpb1GXUXMV" /></p>
<p>In 
<a href="https://medium.freecodecamp.org/how-to-generate-your-very-own-bitcoin-private-key-7ad0f4936e6c">the first article</a>
 of this series, we generated a bitcoin private key: 
<code>60cf347dbc59d31c1358c8e5cf5e45b822ab85b79cb32a9f3d98184779a9efc2</code>.</p>
<p>Here, we’ll use that key to get the public address and then the Ethereum wallet address of that private key.
Creating the Bitcoin wallet address from the private key is a bit complicated. Here, the process will be much simpler. We need to apply one hash function to get the public key and another one to get the address.
So let’s get started.</p>
<h3 id="public-key">Public key<a class="headerlink" href="#public-key" title="Permanent link"></a></h3>
<p>This part is almost identical to what we discussed in the 
<a href="https://medium.freecodecamp.org/how-to-create-a-bitcoin-wallet-address-from-a-private-key-eca3ddd9c05f">Bitcoin article</a>
 , so if you read that one, you can skip it (unless you need a refresher).</p>
<p>The first thing we need to go is to apply the ECDSA, or Elliptic Curve Digital Signature Algorithm, to our private key. An elliptic curve is a curve defined by the equation 
<code>y² = x³ + ax + b</code>
 with chosen 
<code>a</code>
 and 
<code>b</code>
 . There is a whole family of such curves that are widely known and used. Bitcoin uses the 
<strong>secp256k1</strong>
 curve. If you want to learn more about Elliptic Curve Cryptography, I’ll refer you to 
<a href="https://hackernoon.com/what-is-the-math-behind-elliptic-curve-cryptography-f61b25253da3">this article</a>
 .</p>
<p>Ethereum uses the same elliptic curve, 
<strong>secp256k1</strong>
 , so the process to get the public key is identical in both cryptocurrencies.
By applying the ECDSA to the private key, we get a 64-byte integer, which is two 32-byte integers that represent X and Y of the point on the elliptic curve, concatenated together.
For our example, we got 
<code>1e7bcc70c72770dbb72fea022e8a6d07f814d2ebe4de9ae3f7af75bf706902a7b73ff919898c836396a6b0c96812c3213b99372050853bd1678da0ead14487d7</code>
 .
In Python, it would look like this:</p>
<pre><code>private_key_bytes = codecs.decode(private_key, ‘hex’)
## Get ECDSA public key
key = ecdsa.SigningKey.from_string(private_key_bytes, curve=ecdsa.SECP256k1).verifying_key
key_bytes = key.to_string()
key_hex = codecs.encode(key_bytes, ‘hex’)
</code></pre>
<p>Note: as you can see from the code above, I used a method from the 
<code>ecdsa</code>
 module and I decoded the private key using 
<code>codecs</code>
 . This is relevant more to the Python and less to the algorithm itself, but I will explain what are we doing here to remove possible confusion.
In Python, there are at least two classes that can keep the private and public keys: “str” and “bytes”. The first is a string and the second is a byte array. Cryptographic methods in Python work with a “bytes” class, taking it as input and returning it as the result.
Now, there’s a little catch: a string, say, 
<code>4f3c</code>
 does not equal the byte array 
<code>4f3c</code>
 . Rather, it equals the byte array with two elements, 
<code>O&lt;</code>
 . And that’s what the 
<code>codecs.decode</code>
 method does: it converts a string into a byte array. This will be the same for all cryptographic manipulations that we’ll do in this article.</p>
<h3 id="wallet-address">Wallet address<a class="headerlink" href="#wallet-address" title="Permanent link"></a></h3>
<p>Once we’ve gotten the public key, we can calculate the address. Now, unlike Bitcoin, Ethereum has the same addresses on both the main and all test networks. Users specify the network that they want to use later in the process when they make and sign a transaction.
To make an address from the public key, all we need to do is to apply Keccak-256 to the key and then take the last 20 bytes of the result. And that’s it. No other hash functions, no Base58 or any other conversion. The only thing you need is to add ‘0x’ at the start of the address.
Here’s the Python code:</p>
<pre><code>public_key_bytes = codecs.decode(public_key, ‘hex’)
keccak_hash = keccak.new(digest_bits=256)
keccak_hash.update(public_key_bytes)
keccak_digest = keccak_hash.hexdigest()
## Take the last 20 bytes
wallet_len = 40
wallet = ‘0x’ + keccak_digest[-wallet_len:]
</code></pre>
<h3 id="checksum">Checksum<a class="headerlink" href="#checksum" title="Permanent link"></a></h3>
<p>Now, as you may remember, Bitcoin creates the checksum by hashing the public key and taking the first 4 bytes of the result. This is true for all Bitcoin addresses, so you can’t get the valid address without adding the checksum bytes.
In Ethereum, that’s not how things work. Initially, there were no checksum mechanisms to validate the integrity of the key. However, in 2016, Vitalik Buterin 
<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md">introduced</a>
 a checksum mechanism, which has since been adopted by wallets and exchanges.</p>
<p>Adding a checksum to the Ethereum wallet address makes it case-sensitive.
First, you need to get the Keccak-256 hash of the address. Note that this address should be passed to the hash function without the 
<code>0x</code>
 part.
Second, you iterate over the characters of the initial address. If the 
<em>i</em>
 th byte of the hash is greater than or equal to 8, you convert the 
<em>i</em>
 th address’s character to uppercase, otherwise you leave it lowercase.
Finally, you add 
<code>0x</code>
 back at the start of the resulting string. The checksum address is the same as the initial one if you ignore the case. But the uppercase letters let anyone check that the address is indeed valid. You can find the algorithm of the checksum validation at the 
<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md">page linked here</a>
 .</p>
<p>As you’ll read in the proposal, for this checksum scheme, “on average there will be 15 check bits per address, and the net probability that a randomly generated address if mistyped will accidentally pass a check is 0.0247%.”</p>
<p>And here’s the code to add checksum to the Ethereum address:</p>
<pre><code>checksum = ‘0x’
## Remove ‘0x’ from the address
address = address[2:]
address_byte_array = address.encode(‘utf-8’)
keccak_hash = keccak.new(digest_bits=256)
keccak_hash.update(address_byte_array)
keccak_digest = keccak_hash.hexdigest()
for i in range(len(address)):
    address_char = address[i]
    keccak_char = keccak_digest[i]
    if int(keccak_char, 16) &gt;= 8:
        checksum += address_char.upper()
    else:
        checksum += str(address_char)
</code></pre>
<h3 id="conclusion">Conclusion<a class="headerlink" href="#conclusion" title="Permanent link"></a></h3>
<p>As you can see, creating an address for Ethereum is much simpler than for Bitcoin. All we need to do is to apply the ECDSA to public key, then apply Keccak-256, and finally take the last 20 bytes of that hash.</p>
<p><img alt="" src="https://ipfs.infura.io/ipfs/QmWDnVCb5rQLUQwcggjQcLQnB1vAckGnPUNquo6z92LS3Z" /></p>
<p>If you want to play with the code, I published it to the 
<a href="https://github.com/Destiner/blocksmith">GitHub repository</a>.</p>
<hr />
<p>I also post random thoughts about crypto on 
<a href="https://twitter.com/DestinerX">Twitter</a>, so you might want to check it out.</p>
<hr />
<ul>
<li><strong>Kauri original title:</strong> How to create an Ethereum wallet address from a private key</li>
<li><strong>Kauri original link:</strong> https://kauri.io/how-to-create-an-ethereum-wallet-address-from-a-pr/e464ca2b043a4d2e9e30b01b092dfa13/a</li>
<li><strong>Kauri original author:</strong> Timur Badretdinov (@destiner)</li>
<li><strong>Kauri original Publication date:</strong> 2018-11-29</li>
<li><strong>Kauri original tags:</strong> none</li>
<li><strong>Kauri original hash:</strong> QmSVudzGkE4wLw6ppThaTtHGeHnzfaVte9uPaWCxzwybfa</li>
<li><strong>Kauri original checkpoint:</strong> QmRS3wCLX2MRi62bg9NTM89qNkgm3XjpKXciLvCKAr1f1g</li>
</ul>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../xdai-point-of-sale/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../xdai-point-of-sale/" class="btn btn-xs btn-link">
        xDai Point of Sale
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../the-importance-of-women-in-the-cryptocurrency-ind/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../the-importance-of-women-in-the-cryptocurrency-ind/" class="btn btn-xs btn-link">
        The Importance of Women in the Cryptocurrency Industry
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
      <p>
        <a href="https://github.com/kauri-io/archive/edit/main/docs/single/how-to-create-an-ethereum-wallet-address-from-a-p.md"><i class="fa fa-github"></i>
Edit on GitHub</a>
      </p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>
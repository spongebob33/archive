<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://kauri.io/single/here-s-the-deal-on-sharding/">
    <link rel="shortcut icon" href="../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Here’s The Deal on Sharding - kauri.io</title>
    <link href="../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../js/jquery-3.2.1.min.js"></script>
    <script src="../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Here\u2019s The Deal on Sharding", url: "#_top", children: [
              {title: "ELI5 on Sharding\u2026 Kinda", url: "#eli5-on-sharding-kinda" },
              {title: "Cross-Shard Communication", url: "#cross-shard-communication" },
              {title: "Vulnerabilities", url: "#vulnerabilities" },
              {title: "Putting It All Together", url: "#putting-it-all-together" },
              {title: "It\u2019s Not Perfect", url: "#its-not-perfect" },
          ]},
        ];

    </script>
    <script src="../../js/base.js"></script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-172017815-1', 'kauri.io');
        ga('send', 'pageview');
    </script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    <h1 id="heres-the-deal-on-sharding">Here’s The Deal on Sharding<a class="headerlink" href="#heres-the-deal-on-sharding" title="Permanent link"></a></h1>
<p><img alt="" src="https://ipfs.infura.io/ipfs/QmWYCz2aar8wqVJQfiVFfvDskb8f4nXJbcnb9gLXYc41nJ" /></p>
<p>Blockchains <strong>suck</strong>.</p>
<p>They’re really slow, the fees are high, and right now nearly nothing built on them can scale, as evidenced by Cryptokitties and every single Ethereum stress test since then.</p>
<p>In fact, blockchains are so bad that there’s an infamous “scalability trilemma” to sum up their biggest cons: as they are right now, they can’t exist without having to trade off either <strong>decentralization</strong>, <strong>scalability</strong>, or <strong>security</strong>.</p>
<p>For example: if your blockchain is truly decentralized like Bitcoin, then it’ll have to trade off either scalability or security; in Bitcoin’s case, it’s <strong>scalability</strong>. Bitcoin is really secure due to the amount of hashing power invested into that one chain, as well as the sheer number of nodes. However, because there’s so many nodes, it ends up taking a really long time to process even one transaction since every single node has to verify it in sequence.</p>
<p>Some of the general scalability solutions that have been presented so far are increasing 
<a href="https://en.bitcoin.it/wiki/Block_size_limit_controversy">block size</a>, creating more individual <em>altcoins</em> to deal with separate tasks, and <a href="https://www.cryptocompare.com/mining/guides/what-is-merged-mining-bitcoin-namecoin-litecoin-dogecoin/">merged mining</a>. However, they all have their own pitfalls; block size (or the block gas limit in ETH’s case) cannot be increased indefinitely (increased block size will cause a network to <a href="https://www.newsbtc.com/2017/11/12/61408/">become centralized</a> around a handful of miners), altcoins will spread out hashing power across multiple blockchains which sharply decreases security, and merged mining increases miners’ computational burden.</p>
<h4 id="eli5-on-sharding-kinda">ELI5 on Sharding… Kinda<a class="headerlink" href="#eli5-on-sharding-kinda" title="Permanent link"></a></h4>
<p>Sharding is one of the in-protocol solutions that have been proposed to help Ethereum scale. Sharding splits up the <strong>state</strong> of the network into multiple <em>shards</em> or pieces, where each piece has its own transaction history and portion of the network’s state. (The state is composed of all the information on what the network looks like at one specific moment, for example the amount of transactions that have been processed, the balances at each address, etc.)</p>
<p><img alt="" src="https://ipfs.infura.io/ipfs/QmThKpRX6Q8qBRXYV2Gx985wWSw8f9uMi5VciVBN1K29nU" /></p>
<p>For example, in one sharding mechanism, a certain amount of addresses could be confined to a certain shard. In other words, all addresses beginning with 0x00 could go into shard 1, all addresses beginning with 0x01 could go into shard 2, and so on and so forth. Each new transaction on each individual shard would change the state of <em>that</em> shard only. Inter-shard communication would be facilitated through <a href="https://github.com/ethereum/wiki/wiki/Sharding-FAQs#how-can-we-facilitate-cross-shard-communication">some fancy functionalities</a>, which I’ll explain later.</p>
<p>Every single shard processes its own portion of the <em>state</em> of the network, which allows multiple transactions to be verified in parallel instead of one transaction having to be processed by every single node. In this way, the network would be able to process transactions much, much faster.
With a protocol such as this, we would now have two dimensions of operation instead of just one. Let’s zoom in and start with the first dimension, that of the shards. Check out the diagram below:</p>
<p><img alt="" src="https://ipfs.infura.io/ipfs/QmV5TRFgogCHBmR1KohXBLtqVf2fdG9BLHvufdbjmYTkrR" /></p>
<p>Instead of making blocks of transactions, certain nodes called <em>proposers</em> native to each shard build <em>collations</em>, which are basically groups of transactions.
Each collation has a collation <em>header</em> as seen above, which contains information about the collation — which shard it belongs to, the state of the shard before the transactions were processed, the state of the shard after, and the receipt root after all the transactions are verified. The right side of the header with all the <sig #0000> elements represents <em>notary</em> nodes or <em>collators</em> that are meant to download and verify the collation. These notaries are randomly assigned to each shard, and the assigned shards get shuffled after a set period.</p>
<p>Then, in the body of the collation, we see the collection of all the transaction IDs to be processed.</p>
<p><em>So quick</em> <strong>TL;DR</strong><em>: proposer nodes build collations that are groups of transactions. Collations have headers that contain information about the state of the shard and the nodes that will verify them. The collation bodies contain the transactions.</em></p>
<p>Let’s zoom out a bit to the <strong>2nd dimension of operation</strong> — the “main chain”.</p>
<p>Instead of storing full blocks of transaction, now the main chain — the Proof of Work chain — pretty much solely serves to store the collation headers from each shard that have been properly verified.</p>
<p><img alt="" src="https://ipfs.infura.io/ipfs/Qma7xkvDYxyt7f9XkiXq5kbga3bRMwHAh3pVpmsyf4CwfC" /></p>
<p>So in the diagram above, we can see sort of the “top level” of the protocol, where in each block we store two roots; one that describes the state of the network, which is divided into shards, and one that contains the information about all the verified collation headers. This means that the “longest chain” of each shard is the longest chain that contains every single collation that has been put onto the main chain.</p>
<h4 id="cross-shard-communication">Cross-Shard Communication<a class="headerlink" href="#cross-shard-communication" title="Permanent link"></a></h4>
<p>One of the most important aspects of sharding would be to implement some method of cross-shard communication. What good would it be if you couldn’t send a transaction from address X in shard 1 to address Y in shard 3?</p>
<p>This capability will be constructed via receipts. Remember the receipt root that’s stored in every collation’s header? Those receipts can be easily accessed through the transaction group <a href="https://brilliant.org/wiki/merkle-tree/">Merkle root</a> in the main chain’s “block”. You can think of receipts as byproducts of a transaction stored in a separate data structure (a Merkle tree). They can be easily called by a node to check the existence of a transaction without the node having to download the entire blockchain. Shards will be able to communicate with each other through these receipts. This is a sample process explained on the <a href="https://github.com/ethereum/wiki/wiki/Sharding-FAQs#how-can-we-facilitate-cross-shard-communication">Ethereum Sharding FAQ</a>, where account A from shard M wants to send 100 coins to account B on shard N.</p>
<blockquote>
<ol>
<li>Send a transaction on shard M which (i) deducts the balance of A by 100 coins, and (ii) creates a receipt. A receipt is an object which is not saved in the state directly, but where the fact that the receipt was generated can be verified via a Merkle proof.</li>
<li>Wait for the first transaction to be included (sometimes waiting for finalization is required; this depends on the system).</li>
<li>Send a transaction on shard N which includes the Merkle proof of the receipt from (1). This transaction also checks in the state of shard N to make sure that this receipt is “unspent”; if it is, then it increases the balance of B by 100 coins, and saves in the state that the receipt is spent.</li>
<li>Optionally, the transaction in (3) also saves a receipt, which can then be used to perform further actions on shard M that are contingent on the original operation succeeding.</li>
</ol>
</blockquote>
<p>Essentially there are two processes happening here: one “transaction” simply deducts account A’s balance, and then another transaction, being matched with the receipt from the deduction transaction, adds to account B’s balance the amount that was deducted from A. In this way we can effectively construct a full cross-shard transaction.
If you’re a more visual learner, here’s a diagram describing the same process:</p>
<p><img alt="" src="https://ipfs.infura.io/ipfs/QmbSbpfAGBDBcaL41K1FRSZe92zfxw8i69muzhJztcEtvL" /></p>
<h4 id="vulnerabilities">Vulnerabilities<a class="headerlink" href="#vulnerabilities" title="Permanent link"></a></h4>
<p>So sharding sounds amazing and all, but you must be thinking that there <em>has</em> to be a catch somewhere. Well, you’re right. </p>
<p>The biggest issue the sharding solution might have to face is the single-shard takeover attack. A blockchain insures security through the validation of each transaction by every single node in the network. However, when the state of the network is sharded, each node will only process a certain portion of each transaction. This will make it more difficult to keep the information secure. It will be comparatively easy to take over all the proposers, collators and notaries in a shard in order to submit false collations.</p>
<p><img alt="" src="https://ipfs.infura.io/ipfs/QmXrQBwH91CqZ8CmDeWQrse2YqdwsCVD44w1PoFJ1hyA4f" /></p>
<p>The primary way Ethereum aims to solve this issue is through <strong>random sampling</strong>. A certain number of <em>notaries</em> are assigned to each shard to verify the collations, and as mentioned before, the assigned shards will shuffle after a set period of time.</p>
<p>There are two ways this can happen. Notaries may be <strong>explicitly</strong> <strong>chosen</strong> and grouped into <em>committees</em> to vote on whether collations are valid or not. They can also be <strong>implicitly</strong> expected to go back through the chain and verify a certain number of older parent collations with each new collation that they process.
With this restriction, even though there’s only a fraction of the total nodes that are processing new transactions on each shard, the level of security will still relatively remain the same. We can apply the theory of binomial distribution here:</p>
<p><img alt="" src="https://ipfs.infura.io/ipfs/QmekAgKMUHKA4qPDj7Pi34FgVb9uTmCLjgdmgZx229K3Hr" /></p>
<p>The total area under each dotted line represents the total number of nodes in the network. The portions under the humps show where the majority of the nodes are. The numbers on the x-axis represent the number of honest nodes out of the total set. The more the hump leans towards the right of the diagram, the more nodes in the network are honest. The more the hump leans towards the left, the less nodes are honest. The blue line represents a 50–50 chance of a node being honest with a 20-node sample size, the green represents a 70–30 chance of the node being honest with a 20-node sample size, and so on and so forth.</p>
<p>For this reason, if we go along with statistic probability and assume that the majority of the nodes, around 67%, will be honest, that means the “hump” of our binomial distribution will skew more towards the right. Because of this, if we take a smaller sample (say 150 nodes) representing 1 shard out of the total number of nodes, we will see that there’s <a href="https://github.com/ethereum/wiki/wiki/Sharding-FAQs#how-can-we-solve-the-single-shard-takeover-attack-in-an-uncoordinated-majority-model">practically a 100% probability</a> that the shard will have a majority of honest nodes.
In this way, attackers will have to actually control 100% - 67% = 33% of the network to actually present a real threat if the sharding solution were implemented.</p>
<h4 id="putting-it-all-together">Putting It All Together<a class="headerlink" href="#putting-it-all-together" title="Permanent link"></a></h4>
<p>So now we have all of these excellent capabilities that present a solid attempt to patch up some of the biggest challenges sharding presents. We can actually implement and connect all of them through two things; the <strong>Proof of Stake beacon chain</strong>, and the <strong>Validator Manager Contract</strong>.</p>
<p>Remember when I talked about how the sharding proposal will split Ethereum into 2 dimensions of operation? Instead of using the main Proof of Work chain as the “top-level” element for storing validated collations and state information, Ethereum is actually looking towards transitioning to use a Proof of Stake chain (their Casper chain) to replace this function. Also called a beacon chain, this one will manage and store the set of notaries and collators chosen to validate each collation during a given period of time. On the PoS chain, these nodes will be known as <em>validators</em>.
Furthermore, instead of storing transaction group roots, the beacon chain will be composed of elements called <strong>cross-links.</strong> These are types of transactions that contain the hash of a recently validated collation on a certain shard, and prove that the 2/3 of the selected validators have approved that collation.</p>
<p>Currently, in order to become a validator on the Proof of Stake chain, you must submit a stake of 32 ethers onto the Validator Manager Contract (VMC), which essentially keeps track of which validator is doing what. If you do not validate the appropriate collations, your stake will not be returned by the VMC. It’s kinda like a security deposit. The VMC’s role is essentially to do the random sampling of validators, verify collation header hashes, and facilitate cross-shard communication via receipts.</p>
<h4 id="its-not-perfect">It’s Not Perfect<a class="headerlink" href="#its-not-perfect" title="Permanent link"></a></h4>
<p>It may seem like a super comprehensive solution, and in most ways it is, but the sharding proposal still has a lot that needs to be figured out. First of all, we actually have no idea how well this will be pulled off and what issues we haven’t taken into account because <a href="https://www.infoq.com/news/2018/06/Ethereum-Casper-First-Release">Casper hasn’t been fully implemented yet</a>. A lot of rough knots also need to be worked out in the cross-communication scheme, because 
<a href="https://github.com/ethereum/wiki/wiki/Sharding-FAQs#what-is-the-train-and-hotel-problem">atomic operations</a> (where if one transaction fails, then all of the rest must be cancelled as well) still haven’t been figured out. There’s also a lot of other problems in terms of the logistics of verification, and how to carry out certain security mechanisms.</p>
<p>If you’d like to continue onto learning about the sharding proposal in more depth, I recommend going through the links sprinkled throughout this article, as well as reading the 
<a href="https://github.com/ethereum/sharding/blob/develop/docs/doc.md">official doc</a>.</p>
<blockquote>
<p>I hope this was helpful! Please let me know any questions you may have, and any feedback as well if I’ve misrepresented any information. Thank you for reading! Be sure to follow me for more articles like this. Note: this article was originally written in July 2018, and may not be up to date in certain areas.</p>
</blockquote>
<hr />
<ul>
<li><strong>Kauri original title:</strong> Here’s The Deal on Sharding</li>
<li><strong>Kauri original link:</strong> https://kauri.io/heres-the-deal-on-sharding/04b66cfa4382448c93440ebf3da26224/a</li>
<li><strong>Kauri original author:</strong> Ramy Zhang (@ramyjzhang)</li>
<li><strong>Kauri original Publication date:</strong> 2019-03-07</li>
<li><strong>Kauri original tags:</strong> ethereum, casper, sharding, scalability</li>
<li><strong>Kauri original hash:</strong> QmZHMuNVnJP3cid6Nwgac4pLfrHd6WHuRgZMtPaMk73aKD</li>
<li><strong>Kauri original checkpoint:</strong> QmYRYAA1TRyDiXS6uLXdt6qS8AnW63tqJHYpUQKrdyNz7h</li>
</ul>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../make-it-bulletproof/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../make-it-bulletproof/" class="btn btn-xs btn-link">
        Make it Bulletproof
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../ethereum-foundation-sponsor-bounty-at-ethdenver20/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../ethereum-foundation-sponsor-bounty-at-ethdenver20/" class="btn btn-xs btn-link">
        Ethereum Foundation - Sponsor Bounty at ETHDenver2019!
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
      <p>
        <a href="https://github.com/kauri-io/archive/edit/main/docs/single/here-s-the-deal-on-sharding.md"><i class="fa fa-github"></i>
Edit on GitHub</a>
      </p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>
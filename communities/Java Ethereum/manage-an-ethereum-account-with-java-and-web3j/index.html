<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://kauri.io/communities/Java%20Ethereum/manage-an-ethereum-account-with-java-and-web3j/">
    <link rel="shortcut icon" href="../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Manage an Ethereum account with Java and Web3j - kauri.io</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Manage an Ethereum account with Java and Web3j", url: "#_top", children: [
              {title: "1. Retrieve public information about an account", url: "#1-retrieve-public-information-about-an-account" },
              {title: "2. Open or create an account", url: "#2-open-or-create-an-account" },
              {title: "3. Send a transaction", url: "#3-send-a-transaction" },
              {title: "Summary", url: "#summary" },
              {title: "Resources", url: "#resources" },
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-172017815-1', 'kauri.io');
        ga('send', 'pageview');
    </script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    <h1 id="manage-an-ethereum-account-with-java-and-web3j">Manage an Ethereum account with Java and Web3j<a class="headerlink" href="#manage-an-ethereum-account-with-java-and-web3j" title="Permanent link"></a></h1>
<p><img alt="" src="https://ipfs.infura.io/ipfs/QmTyEg3Lq2Bf2anauJnHcGtHiAJZ71kAbY2quL7jXZeWkh" /></p>
<p><strong>Other articles in this series:</strong></p>
<ul>
<li><a href="https://kauri.io/article/b9eb647c47a546bc95693acc0be72546">Connecting to an Ethereum client with Java, Eclipse and Web3j</a></li>
<li><a href="https://kauri.io/article/84475132317d4d6a84a2c42eb9348e4b">Generate a Java Wrapper from your Smart Contract</a></li>
<li><a href="https://kauri.io/article/14dc434d11ef4ee18bf7d57f079e246e">Interacting with an Ethereum Smart Contract in Java</a></li>
<li><a href="https://kauri.io/article/760f495423db42f988d17b8c145b0874">Listening for Ethereum Smart Contract Events in Java</a></li>
<li><a href="https://kauri.io/article/276dd27f1458443295eea58403fd6965">Using Pantheon, the Java Ethereum Client with Linux</a></li>
</ul>
<hr />
<p>The Ethereum blockchain is often compared to a World Computer with a global state. The global state grows after each new block and cosists of many accounts organised in a <a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle tree</a>.</p>
<p><img alt="" src="https://imgur.com/iQLdaOW.png" /></p>
<p>Each account has a state composed of information such as balance, nonce, storageRoot and codeHash, and is identified by a 20 bytes address (for example: <code>0x66aac71c0c81ec00aebead84914a10e307a4cbf9</code>).</p>
<p>There are two types of accounts:</p>
<ul>
<li><strong>Externally owned accounts</strong>, which are controlled by private keys and have no code associated with them.</li>
<li><strong>Contract accounts</strong>, which are controlled by their contract code and have code associated with them.</li>
</ul>
<p><img alt="" src="https://imgur.com/3dlka35.png" /></p>
<p>In this tutorial, we focus on externally owned accounts and how to retrieve information such as a balance, create or open an account and send transactions to another account using the Java library <a href="https://web3j.io/">Web3j</a>.</p>
<p><br /><br /></p>
<h3 id="1-retrieve-public-information-about-an-account">1. Retrieve public information about an account<a class="headerlink" href="#1-retrieve-public-information-about-an-account" title="Permanent link"></a></h3>
<p>The Ethereum blockchain is a public shared ledger which we can query to retrieve information about the state at a different time, or block number.</p>
<h4 id="get-accounts-balance">Get account's balance<a class="headerlink" href="#get-accounts-balance" title="Permanent link"></a></h4>
<p>Every account has a balance of the Ethereum native cryptocurrency called <strong>Ether</strong>. Using our Web3j instance (see <a href="#">article-1</a>), it is possible to retrieve the balance of an account at a given block using the function <code>web3.ethGetBalance(&lt;accountAddress&gt;, &lt;blockNo&gt;).send()</code></p>
<p>The balance is stored by default in the smallest denomination of ether called <em>wei</em> (1 ether = 10^18 wei) but Web3j provides a convenience utility class <code>Convert</code> to convert values between different units.</p>
<ul>
<li>Retrieve the latest balance (latest block) of an account:</li>
</ul>
<pre><code class="language-java">EthGetBalance balanceWei = web3.ethGetBalance(&quot;0xF0f15Cedc719B5A55470877B0710d5c7816916b1&quot;, DefaultBlockParameterName.LATEST).send();
System.out.println(&quot;balance in wei: &quot; + balanceWei);

BigDecimal balanceInEther = Convert.fromWei(balanceWei.getBalance().toString(), Unit.ETHER);
System.out.println(&quot;balance in ether: &quot; + balanceInEther);
</code></pre>
<p><img alt="" src="https://imgur.com/S7w0eEH.png" /></p>
<p>In the example above, the latest balance of the account <code>0xF0f15Cedc719B5A55470877B0710d5c7816916b1</code> is <em>33.25 ether</em>.</p>
<ul>
<li>Retrieve the balance of an account at a specific block, if the blockchain you connect to has generated any blocks so far. Test chains may not have yet:</li>
</ul>
<pre><code class="language-java">EthGetBalance balance = web3.ethGetBalance(&quot;0xF0f15Cedc719B5A55470877B0710d5c7816916b1&quot;, new DefaultBlockParameterNumber(3000000)).send();

BigDecimal balanceInEther = Convert.fromWei(balance.getBalance().toString(), Unit.ETHER);
</code></pre>
<p><img alt="" src="https://imgur.com/PuUtKHV.png" /></p>
<p>The balance at block #3,000,000 of the account <code>0xF0f15Cedc719B5A55470877B0710d5c7816916b1</code> is <em>8.12 ethers</em>.</p>
<h4 id="get-accounts-nonce">Get account's nonce<a class="headerlink" href="#get-accounts-nonce" title="Permanent link"></a></h4>
<p>Also included in the state of an account is the <em>nonce</em>, a sequence number symbolizing the number of transactions performed by an account.</p>
<p>Web3j provides the method <code>web3.ethGetTransactionCount(&lt;accountAddress&gt;, &lt;blockNo&gt;).send()</code> to retrieve the nonce at a given block number, in this case the most recent block.</p>
<pre><code class="language-java">EthGetTransactionCount ethGetTransactionCount = web3.ethGetTransactionCount(&quot;0xF0f15Cedc719B5A55470877B0710d5c7816916b1&quot;, DefaultBlockParameterName.LATEST).send();

BigInteger nonce =  ethGetTransactionCount.getTransactionCount();
</code></pre>
<p><img alt="" src="https://imgur.com/uJ2bcNk.png" /></p>
<p><br /><br /></p>
<h3 id="2-open-or-create-an-account">2. Open or create an account<a class="headerlink" href="#2-open-or-create-an-account" title="Permanent link"></a></h3>
<p>In order to control an externally owned account and the fund allocated on it, the 32 bytes <strong>Private Key</strong> associated to an account is needed. A private key is a confidential piece of information, so it usually doesn't come in clear text like <code>3a1076bf45ab87712ad64ccb3b10217737f7faacbf2872e88fdd9a537d8fe266</code> but is secured and encrypted in a wallet. There are many forms of wallets (more or less secured and practical):</p>
<p><img alt="" src="https://imgur.com/N74l0TI.png" /></p>
<p><img alt="" src="https://imgur.com/m4JjJsM.png" /></p>
<p><img alt="" src="https://imgur.com/X8mANUY.png" /></p>
<p>In this section, we learn how to load an existing wallet and create a new one with Web3j to instanciate a <code>Credentials</code> object which we can use to sign and send transactions securely on the Ethereum blockchain.</p>
<h4 id="load-a-wallet">Load a wallet<a class="headerlink" href="#load-a-wallet" title="Permanent link"></a></h4>
<h5 id="from-a-json-encryted-keystore">From a JSON encryted keystore<a class="headerlink" href="#from-a-json-encryted-keystore" title="Permanent link"></a></h5>
<p>The first form of wallet is the JSON encryted keystore, which is a password-encrypted version of the private key. This is the most standard way used by clients such as <a href="https://pegasys.tech/">Pantheon</a> or <a href="https://geth.ethereum.org/">Geth</a>, but also by online tools like <a href="https://www.myetherwallet.com/">MyEtherWallet</a> to secure a private key from potential attackers.</p>
<p>Web3j provides a utility class called <code>WalletUtils</code> to load a wallet into a <code>Credentials</code> object (wrapper containing the account address and the keypair).</p>
<pre><code class="language-java">String walletPassword = &quot;secr3t&quot;;
String walletDirectory = &quot;/path/to/wallets&quot;;
String walletName = &quot;UTC--2019-06-20T08-55-56.200000000Z--fd7d68e16ef61868f3e325fafdf2fc1ec0b77649.json&quot;;

// Load the JSON encryted wallet
Credentials credentials = WalletUtils.loadCredentials(walletPassword, walletDirectory + &quot;/&quot; + walletName);

// Get the account address
String accountAddress = credentials.getAddress();

// Get the unencrypted private key into hexadecimal
String privateKey = credentials.getEcKeyPair().getPrivateKey().toString(16);
</code></pre>
<p><img alt="" src="https://imgur.com/p92p616.png" /></p>
<h5 id="from-a-mnemonic-phrase">From a Mnemonic phrase<a class="headerlink" href="#from-a-mnemonic-phrase" title="Permanent link"></a></h5>
<p>Another common form of private key is the <strong>Mnemonic sentence</strong> (or seed phrase) which converts the 32 bytes key to a group of 12 easy to remember words. For example: <code>candy maple cake sugar pudding cream honey rich smooth crumble sweet treat</code>. This form was established by Bitcoin under the proposal <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP39</a>.</p>
<p>A mnemonic controls multiple private keys because of a mechanism to derive deterministically the mnemonic from a path.</p>
<p>We can optionally encrypt the mnemonic with a password.</p>
<pre><code class="language-java">String password = null; // no encryption
String mnemonic = &quot;candy maple cake sugar pudding cream honey rich smooth crumble sweet treat&quot;;

Credentials credentials = WalletUtils.loadBip39Credentials(password, mnemonic);
</code></pre>
<p><img alt="" src="https://imgur.com/xN2Ruaj.png" /></p>
<p>By default, Web3j uses a derivation path equal to <code>m/44'/60'/0'/1</code> (read <a href="https://medium.com/myetherwallet/hd-wallets-and-derivation-paths-explained-865a643c7bf2">this article</a> to understand <em>derivation path</em>). However, it is possible to open another account on a different path:</p>
<pre><code class="language-java">String password = null; // no encryption
String mnemonic = &quot;candy maple cake sugar pudding cream honey rich smooth crumble sweet treat&quot;;

//Derivation path wanted: // m/44'/60'/0'/0
int[] derivationPath = {44 | Bip32ECKeyPair.HARDENED_BIT, 60 | Bip32ECKeyPair.HARDENED_BIT, 0 | Bip32ECKeyPair.HARDENED_BIT, 0,0};

// Generate a BIP32 master keypair from the mnemonic phrase
Bip32ECKeyPair masterKeypair = Bip32ECKeyPair.generateKeyPair(MnemonicUtils.generateSeed(mnemonic, password));

// Derived the key using the derivation path
Bip32ECKeyPair  derivedKeyPair = Bip32ECKeyPair.deriveKeyPair(masterKeypair, derivationPath);

// Load the wallet for the derived key
Credentials credentials = Credentials.create(derivedKeyPair);
</code></pre>
<p><img alt="" src="https://imgur.com/eEgEdOY.png" /></p>
<h5 id="from-a-private-key">From a Private key<a class="headerlink" href="#from-a-private-key" title="Permanent link"></a></h5>
<p>As mentioned before, a private key is a 32 bytes long number. To parse a private key with Web3j, we need to pass the private key to the class <code>Credentials</code>.</p>
<pre><code class="language-java">String pk = &quot;c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3&quot;;

Credentials credentials = Credentials.create(pk);
</code></pre>
<p><img alt="" src="https://imgur.com/svlvLnF.png" /></p>
<h4 id="create-a-wallet">Create a wallet<a class="headerlink" href="#create-a-wallet" title="Permanent link"></a></h4>
<p>Finally, if we don't already have an account and want to create a new one from scratch. Web3j's <code>WalletUtils</code> offers a method to create a JSON encrypted keystore.</p>
<pre><code class="language-java">String walletPassword = &quot;secr3t&quot;;
String walletDirectory = &quot;/path/to/destination/&quot;;

String walletName = WalletUtils.generateNewWalletFile(walletPassword, new File(walletDirectory));
System.out.println(&quot;wallet location: &quot; + walletDirectory + &quot;/&quot; + walletName);


Credentials credentials = WalletUtils.loadCredentials(walletPassword, walletDirectory + &quot;/&quot; + walletName);

String accountAddress = credentials.getAddress();
System.out.println(&quot;Account address: &quot; + credentials.getAddress());
</code></pre>
<p><img alt="" src="https://imgur.com/kbcemsH.png" /></p>
<p><br /><br /></p>
<h3 id="3-send-a-transaction">3. Send a transaction<a class="headerlink" href="#3-send-a-transaction" title="Permanent link"></a></h3>
<p>Now we have learned how to retrieve public information (state), like the balance from an account and how to open an account using different methods, we can send a transaction to another account.</p>
<p>A transaction on the Ethereum blockchain is composed of the following information:</p>
<ul>
<li><strong>nonce:</strong> a count of the number of transaction sent by the sender.</li>
<li><strong>gasPrice (in wei):</strong> the amount the sender is willing to pay per unit of gas required to execute the transaction.</li>
<li><strong>gasLimit:</strong> the maximum amount of gas the sender is willing to pay to execute this transaction.</li>
<li><strong>to:</strong> The address of the recipient account.</li>
<li><strong>value (in wei):</strong> the amount of Wei to transfer from the sender to the recipient. In a contract-creating transaction, this value serves as the starting balance within the newly created contract account.</li>
<li><strong>signature:</strong> Cryptographic signature that identified the sender of the transaction (from).</li>
<li><strong>data:</strong> Optional field used to communicate with a smart contract (encoded string including the function name and the parameters).</li>
</ul>
<p>There are two ways to send a transaction to the blockchain:</p>
<ul>
<li>
<p><strong>Via the Ethereum node:</strong>
    This involves sending a non-signed transaction to the Ethereum client having the account <em>unlocked</em>.
    <strong><em>I personnaly don't recommend this method which might put your account at risk if the Ethereum node isn't correctly protected</em></strong></p>
</li>
<li>
<p><strong>Offline transaction:</strong>
    The concept is to first construct the transaction object <code>rawTransaction</code> and sign it with a private key (Web3j Credential). Secondly send it to the Ethereum node via the JSON-RPC API to propagate across the network.</p>
</li>
</ul>
<p>Once a transaction is broadcast to the network, a transaction hash is returned to the client but the transaction isn't performed yet. A set of miners/validators present on the network pick up all the pending transactions, group them into the next block and agree on the validity. Once verified, the transaction is mined into the new block. At this point, the client can claim a transaction receipt by transaction hash to aknowledge the good execution of his transaction.</p>
<p><img alt="" src="https://web3j.readthedocs.io/en/latest/_images/web3j_transaction.png" /></p>
<h4 id="send-funds-from-one-account-to-another">Send funds from one account to another<a class="headerlink" href="#send-funds-from-one-account-to-another" title="Permanent link"></a></h4>
<h5 id="1-load-an-account-and-get-the-nonce">1. Load an account and get the nonce<a class="headerlink" href="#1-load-an-account-and-get-the-nonce" title="Permanent link"></a></h5>
<p>As explained in the previous sections, we need to load an account from one the methods and retrieve the nonce value of this account:</p>
<pre><code class="language-java">String walletPassword = &quot;secr3t&quot;;
String walletPath = &quot;/path/to/wallet/UTC--2019-06-20T11-41-39.478000000Z--256c75c85f9c27ac5b2a22f085d9643f7ed91dc1.json&quot;;

// Decrypt and open the wallet into a Credential object
Credentials credentials = WalletUtils.loadCredentials(walletPassword, walletPath);

// Get nonce
EthGetTransactionCount ethGetTransactionCount = web3.ethGetTransactionCount(credentials.getAddress(), DefaultBlockParameterName.LATEST).send();
BigInteger nonce =  ethGetTransactionCount.getTransactionCount();
</code></pre>
<h5 id="2-configure-recipient-account-and-amount-to-send">2. Configure recipient account and amount to send<a class="headerlink" href="#2-configure-recipient-account-and-amount-to-send" title="Permanent link"></a></h5>
<p>In the next step, we configure the amount (in Wei) to send to a recipient account.</p>
<pre><code class="language-java">// Recipient account
String recipientAddress = &quot;0xDD6325C45aE6fAbD028D19fa1539663Df14813a8&quot;;

// Value to Transfer
BigInteger value = Convert.toWei(&quot;1&quot;, Unit.ETHER).toBigInteger();
</code></pre>
<h5 id="3-configure-gas-parameters">3. Configure Gas parameters<a class="headerlink" href="#3-configure-gas-parameters" title="Permanent link"></a></h5>
<p>Gas represents the fees of the network which taken by the miner who mines the block which includes your transaction.</p>
<p>When sending a transaction, two parameters are important:</p>
<ul>
<li>
<p><strong>Gas Limit (in unit):</strong> Gas limit refers to the maximum amount of gas you're willing to spend on a particular transaction. After the transaction is executed, if too much gas (<code>gasLimit</code>) was sent, the remaining gas is refunded to the sender.</p>
</li>
<li>
<p><strong>Gas Price (in wei):</strong> Amount of Ether you're willing to pay for every unit of gas</p>
</li>
</ul>
<pre><code class="language-java">// A transfer cost 21,000 units of gas
BigInteger gasLimit = BigInteger.valueOf(21000);

// I am willing to pay 1Gwei (1,000,000,000 wei or 0.000000001 ether) for each unit of gas consumed by the transaction.
BigInteger gasPrice = Convert.toWei(&quot;1&quot;, Unit.GWEI).toBigInteger();
</code></pre>
<h5 id="4-prepare-the-raw-transaction">4. Prepare the raw transaction<a class="headerlink" href="#4-prepare-the-raw-transaction" title="Permanent link"></a></h5>
<p>A raw transaction for a transfer of funds contains all the transaction data fields except:</p>
<ul>
<li><strong>data</strong>: not a smart contract transaction</li>
<li><strong>signature</strong>: signature not signed yet</li>
</ul>
<pre><code class="language-java">// Prepare the rawTransaction
RawTransaction rawTransaction  = RawTransaction.createEtherTransaction(
    nonce,
    gasPrice,
    gasLimit,
    recipientAddress,
    value);
</code></pre>
<h5 id="5-signature">5. Signature<a class="headerlink" href="#5-signature" title="Permanent link"></a></h5>
<p>The signing part requires the <code>rawTransaction</code> as well as the <code>credentials</code> (keypair) used to cryptographically sign the transaction.</p>
<pre><code class="language-java">// Sign the transaction
byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, credentials);

// Convert it to Hexadecimal String to be sent to the node
String hexValue = Numeric.toHexString(signedMessage);
</code></pre>
<h5 id="6-send-to-the-node-via-json-rpc">6. Send to the node via JSON-RPC<a class="headerlink" href="#6-send-to-the-node-via-json-rpc" title="Permanent link"></a></h5>
<p>The final step consists of sending the transaction signed to the node so it can be verified and broadcast to the network. In case of success, the method returns a response composed of the transaction hash.</p>
<pre><code class="language-java">// Send transaction
EthSendTransaction ethSendTransaction = web3.ethSendRawTransaction(hexValue).send();

// Get the transaction hash
String transactionHash = ethSendTransaction.getTransactionHash();
</code></pre>
<h5 id="7-wait-for-the-transaction-to-be-mined">7. Wait for the transaction to be mined.<a class="headerlink" href="#7-wait-for-the-transaction-to-be-mined" title="Permanent link"></a></h5>
<p>As explained before, when the signed transaction is propagated to the network, depending on many factors (gas price, network congestion) it can take some time to see the transaction mined and added to the last block.</p>
<p>That's why the following code consists of a simple loop to verify every 3 seconds if the transaction is mined by calling the method <code>web3.ethGetTransactionReceipt(&lt;txhash&gt;).send()</code>.</p>
<pre><code class="language-java">// Wait for transaction to be mined
Optional&lt;TransactionReceipt&gt; transactionReceipt = null;
do {
  EthGetTransactionReceipt ethGetTransactionReceiptResp = web3.ethGetTransactionReceipt(transactionHash).send();
  transactionReceipt = ethGetTransactionReceiptResp.getTransactionReceipt();

  Thread.sleep(3000); // Retry after 3 sec
} while(!transactionReceipt.isPresent());
</code></pre>
<h5 id="result">Result<a class="headerlink" href="#result" title="Permanent link"></a></h5>
<p>Here is the full version of the code including everything explained in this article:</p>
<pre><code class="language-java">// Transaction.java
package io.kauri.tutorials.java_ethereum;

import java.io.IOException;
import java.math.BigInteger;
import java.util.Optional;

import org.web3j.crypto.Credentials;
import org.web3j.crypto.RawTransaction;
import org.web3j.crypto.TransactionEncoder;
import org.web3j.protocol.Web3j;
import org.web3j.protocol.core.DefaultBlockParameterName;
import org.web3j.protocol.core.methods.response.EthGetTransactionCount;
import org.web3j.protocol.core.methods.response.EthGetTransactionReceipt;
import org.web3j.protocol.core.methods.response.EthSendTransaction;
import org.web3j.protocol.core.methods.response.TransactionReceipt;
import org.web3j.protocol.http.HttpService;
import org.web3j.utils.Convert;
import org.web3j.utils.Convert.Unit;
import org.web3j.utils.Numeric;

public class Transaction {

  public static void main(String[] args)  {

    System.out.println(&quot;Connecting to Ethereum ...&quot;);
    Web3j web3 = Web3j.build(new HttpService(&quot;https://rinkeby.infura.io/v3/083836b2784f48e19e03487eb3209923&quot;));
    System.out.println(&quot;Successfuly connected to Ethereum&quot;);

    try {
      String pk = &quot;CHANGE_ME&quot;; // Add a private key here

      // Decrypt and open the wallet into a Credential object
      Credentials credentials = Credentials.create(pk);
      System.out.println(&quot;Account address: &quot; + credentials.getAddress());
      System.out.println(&quot;Balance: &quot; + Convert.fromWei(web3.ethGetBalance(credentials.getAddress(), DefaultBlockParameterName.LATEST).send().getBalance().toString(), Unit.ETHER));

      // Get the latest nonce
      EthGetTransactionCount ethGetTransactionCount = web3.ethGetTransactionCount(credentials.getAddress(), DefaultBlockParameterName.LATEST).send();
      BigInteger nonce =  ethGetTransactionCount.getTransactionCount();

      // Recipient address
      String recipientAddress = &quot;0xAA6325C45aE6fAbD028D19fa1539663Df14813a8&quot;;

      // Value to transfer (in wei)
      BigInteger value = Convert.toWei(&quot;1&quot;, Unit.ETHER).toBigInteger();

      // Gas Parameters
      BigInteger gasLimit = BigInteger.valueOf(21000);
      BigInteger gasPrice = Convert.toWei(&quot;1&quot;, Unit.GWEI).toBigInteger();

      // Prepare the rawTransaction
      RawTransaction rawTransaction  = RawTransaction.createEtherTransaction(
                 nonce,
                 gasPrice,
                 gasLimit,
                 recipientAddress,
                 value);

      // Sign the transaction
      byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, credentials);
      String hexValue = Numeric.toHexString(signedMessage);

      // Send transaction
      EthSendTransaction ethSendTransaction = web3.ethSendRawTransaction(hexValue).send();
      String transactionHash = ethSendTransaction.getTransactionHash();
      System.out.println(&quot;transactionHash: &quot; + transactionHash);

      // Wait for transaction to be mined
      Optional&lt;TransactionReceipt&gt; transactionReceipt = null;
      do {
        System.out.println(&quot;checking if transaction &quot; + transactionHash + &quot; is mined....&quot;);
            EthGetTransactionReceipt ethGetTransactionReceiptResp = web3.ethGetTransactionReceipt(transactionHash).send();
            transactionReceipt = ethGetTransactionReceiptResp.getTransactionReceipt();
            Thread.sleep(3000); // Wait 3 sec
      } while(!transactionReceipt.isPresent());

      System.out.println(&quot;Transaction &quot; + transactionHash + &quot; was mined in block # &quot; + transactionReceipt.get().getBlockNumber());
      System.out.println(&quot;Balance: &quot; + Convert.fromWei(web3.ethGetBalance(credentials.getAddress(), DefaultBlockParameterName.LATEST).send().getBalance().toString(), Unit.ETHER));


    } catch (IOException | InterruptedException ex) {
      throw new RuntimeException(ex);
    }
  }
}
</code></pre>
<p><img alt="" src="https://imgur.com/8XU21KA.gif" /></p>
<p>Now we understand the core principles behind sending transactions with Web3j, I can tell you a secret. Web3j provides a Utility class called 'Transfer' which takes care of everything (nonce, gas, transaction receipt polling, etc.) in one line of code.</p>
<pre><code class="language-java">TransactionReceipt receipt = Transfer.sendFunds(web3, credentials, recipientAddress, BigDecimal.valueOf(1), Unit.ETHER).send();
</code></pre>
<h3 id="summary">Summary<a class="headerlink" href="#summary" title="Permanent link"></a></h3>
<p>In this article, we learnt that the Ethereum Global State is composed of a mapping of all accounts states. We can query each account state can be queried to get information like the balance and the nonce.</p>
<p>An account is controlled by the person owning the private key of this account. The private key can have many forms and is usually secured in a wallet. Web3j allows to open a wallet from a JSON encrypted file, a mnemonic phrase or directly from the private key.</p>
<p>To send a transaction between two accounts, Web3j can generate a transaction oject, sign it and propagate it to the network to poll the Blockchain to get the transaction receipt when it's been mined.</p>
<p><br /><br /></p>
<h3 id="resources">Resources<a class="headerlink" href="#resources" title="Permanent link"></a></h3>
<ul>
<li><a href="https://etherconverter.online/">Ethereum Unit converter (WEI, GWEI, ETHER, ....)</a></li>
<li><a href="https://web3j.readthedocs.io/en/latest/transactions.html#transaction-signing-via-an-ethereum-client">Web3j Transaction doc</a></li>
<li><a href="https://github.com/web3j/web3j/blob/master/integration-tests/src/test/java/org/web3j/protocol/scenarios/CreateRawTransactionIT.java">Web3j RawTransaction Integration Tests</a></li>
<li><a href="https://masterthecrypto.com/ethereum-what-is-gas-gas-limit-gas-price/">Ethereum - What is Gas Price and Limit</a></li>
<li><a href="https://medium.com/cybermiles/diving-into-ethereums-world-state-c893102030ed">Diving into Ethereum World State</a></li>
</ul>
<p><br /><br />
<strong>Next Steps:</strong>
- <a href="https://kauri.io/article/84475132317d4d6a84a2c42eb9348e4b">Generate a Java Wrapper from your Smart Contract</a>
- <a href="https://kauri.io/article/14dc434d11ef4ee18bf7d57f079e246e">Interacting with an Ethereum Smart Contract in Java</a>
- <a href="https://kauri.io/article/760f495423db42f988d17b8c145b0874">Listening for Ethereum Smart Contract Events in Java</a>
- <a href="https://kauri.io/article/276dd27f1458443295eea58403fd6965">Using Pantheon, the Java Ethereum Client with Linux</a></p>
<hr />
<ul>
<li><strong>Kauri original title:</strong> Manage an Ethereum account with Java and Web3j</li>
<li><strong>Kauri original link:</strong> https://kauri.io/manage-an-ethereum-account-with-java-and-web3j/925d923e12c543da9a0a3e617be963b4/a</li>
<li><strong>Kauri original author:</strong> Grégoire Jeanmart (@gregjeanmart)</li>
<li><strong>Kauri original Publication date:</strong> 2020-05-01</li>
<li><strong>Kauri original tags:</strong> ethereum, java, balance, web3j, account</li>
<li><strong>Kauri original hash:</strong> QmevjY4PmnL2qAc4W6Ev7gWWiPYri4hn2FjXn2AYPoaM62</li>
<li><strong>Kauri original checkpoint:</strong> QmZUeDv5bCt7vrRCQbwPMQf812VWip98dcsMJHdYdaiQ3d</li>
</ul>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../connecting-to-an-ethereum-client-with-java-eclips/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../connecting-to-an-ethereum-client-with-java-eclips/" class="btn btn-xs btn-link">
        Connecting to an Ethereum client with Java, Eclipse and Web3j
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../generate-a-java-wrapper-from-your-smart-contract/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../generate-a-java-wrapper-from-your-smart-contract/" class="btn btn-xs btn-link">
        Generate a Java Wrapper from your Smart Contract
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
      <p>
        <a href="https://github.com/kauri-io/archive/edit/main/docs/communities/Java Ethereum/manage-an-ethereum-account-with-java-and-web3j.md"><i class="fa fa-github"></i>
Edit on GitHub</a>
      </p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>
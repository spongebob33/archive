<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://kauri.io/communities/Ethereum%20Node%20Runners/run-an-ethereum-node-on-debian-with-an-external-s/">
    <link rel="shortcut icon" href="../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Run an Ethereum node on Debian with an External SSD (Mar 2020) - kauri.io</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Run an Ethereum node on Debian with an External SSD (Mar 2020)", url: "#_top", children: [
              {title: "It\u2019s 2020 and you should be running your own Ethereum node", url: "#its-2020-and-you-should-be-running-your-own-ethereum-node" },
              {title: "What is an Ethereum Node?", url: "#what-is-an-ethereum-node" },
              {title: "A Step-by-Step Guide to Running a Geth Node", url: "#a-step-by-step-guide-to-running-a-geth-node" },
              {title: "Requirements", url: "#requirements" },
              {title: "Update: A few words on Ethereum Grid before we get started", url: "#update-a-few-words-on-ethereum-grid-before-we-get-started" },
              {title: "Installation and Sync", url: "#installation-and-sync" },
              {title: "Connect MetaMask", url: "#connect-metamask" },
              {title: "Run a Swarm Node", url: "#run-a-swarm-node" },
              {title: "Setting up an external SSD", url: "#setting-up-an-external-ssd" },
              {title: "Installing and setting up go", url: "#installing-and-setting-up-go" },
              {title: "Installing Geth", url: "#installing-geth" },
              {title: "Syncing with Geth", url: "#syncing-with-geth" },
              {title: "Chrome/Brave", url: "#chromebrave" },
              {title: "Firefox/Tor", url: "#firefoxtor" },
              {title: "A word on full and light Swarm nodes", url: "#a-word-on-full-and-light-swarm-nodes" },
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-172017815-1', 'kauri.io');
        ga('send', 'pageview');
    </script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    <h1 id="run-an-ethereum-node-on-debian-with-an-external-ssd-mar-2020">Run an Ethereum node on Debian with an External SSD (Mar 2020)<a class="headerlink" href="#run-an-ethereum-node-on-debian-with-an-external-ssd-mar-2020" title="Permanent link"></a></h1>
<h2 id="its-2020-and-you-should-be-running-your-own-ethereum-node">It’s 2020 and you should be running your own Ethereum node<a class="headerlink" href="#its-2020-and-you-should-be-running-your-own-ethereum-node" title="Permanent link"></a></h2>
<p><img alt="" src="https://miro.medium.com/max/1920/1*rQm8jb-m6vNm_QCQo6dWnA.png" /></p>
<p><em>Special thanks to</em> <a href="https://twitter.com/gregjeanmart"><em>Gregoire Jeanmart</em></a> <em>for writing the</em> <a href="https://kauri.io/article/9695fcca217f46feb355245275835fc0"><em>tutorial</em></a> <em>that got me off the ground running my own node, and which inspired me to write this. Most of the guide on external SSDs was taken directly from his tutorial, with his permission. Thanks!</em></p>
<p>Node runners are one of many unsung heroes of Ethereum. Especially now that the requirements have been considerably lowered, it’s easier than ever to be a node runner. You can run your node in the background of your preferred machine, and not sacrifice functionality. I hope this guide will be a comprehensive walkthrough on how you can get up and running.</p>
<p>Not only will you get up and running, but you’ll also see how to get MetaMask hooked into your node, and how to run a Swarm node on top of Geth.</p>
<p>This article assumes that you at least vaguely know what Ethereum is, or that you’ve read one of the many excellent articles explaining just that. It also assumes that you’re running on Linux (written for Debian-based distros, commands and locations may vary in other flavors of Linux).</p>
<p><strong>Note:</strong> we are referring to running a full node (in Etherean), meaning not a light client and not an archive node. We’ll just refer to this as “running a node” throughout the piece.</p>
<h2 id="what-is-an-ethereum-node">What is an Ethereum Node?<a class="headerlink" href="#what-is-an-ethereum-node" title="Permanent link"></a></h2>
<h2 id="a-step-by-step-guide-to-running-a-geth-node">A Step-by-Step Guide to Running a Geth Node<a class="headerlink" href="#a-step-by-step-guide-to-running-a-geth-node" title="Permanent link"></a></h2>
<h2 id="requirements">Requirements<a class="headerlink" href="#requirements" title="Permanent link"></a></h2>
<h2 id="update-a-few-words-on-ethereum-grid-before-we-get-started">Update: A few words on Ethereum Grid before we get started<a class="headerlink" href="#update-a-few-words-on-ethereum-grid-before-we-get-started" title="Permanent link"></a></h2>
<h2 id="installation-and-sync">Installation and Sync<a class="headerlink" href="#installation-and-sync" title="Permanent link"></a></h2>
<ul>
<li>Setting up an external SSD</li>
<li>Installing and setting up Go</li>
<li>Installing Geth</li>
<li>Syncing with Geth</li>
</ul>
<h2 id="connect-metamask">Connect MetaMask<a class="headerlink" href="#connect-metamask" title="Permanent link"></a></h2>
<h2 id="run-a-swarm-node">Run a Swarm Node<a class="headerlink" href="#run-a-swarm-node" title="Permanent link"></a></h2>
<p><em>Note that this explanation is somewhat simplified.</em></p>
<p>The records of what has happened on the Ethereum blockchain are distributed around the whole world. This way anyone can access the entire history of Ethereum, and verify against other records that the history that they’re accessing is in fact authentic. Maintaining one of these copies of the history of the blockchain (and updating it whenever there is a new block) is called <em>running a node</em>. The node is your copy of the history.</p>
<p>When anyone wants to make a transaction, they broadcast this to a node. The node then broadcasts this transaction to other nodes on the network. Because of this and other benefits of having your own node, serious dApp projects tend to have their own nodes. This is also how miners can see what transactions are in queue to be mined into the next block. Similarly, a freshly mined block is transmitted to a node and then propagated throughout the system.</p>
<p>If you are a running a node, this means you’ll have a copy of the history of the Ethereum blockchain, and will be in constant contact with the other nodes about what’s going on over the network.</p>
<p>First, we should see if your computer has what it takes.</p>
<p>My understanding from looking around the web is that your CPU shouldn’t be a problem if you’re running on a computer. If you’re running on a Raspberry Pi or the like, I suggest you look at <a href="https://kauri.io/article/9695fcca217f46feb355245275835fc0">this</a> tutorial.</p>
<p>The hard drive is the bigger consideration. While it may be possible to sync up to the chain with an HDD drive, the recommendation is SSD. At least 500GB is recommended. With the improvements in Geth, I can testify that it does not need to be an internal drive — an external SSD that connects by USB is fine. As far as stats go, I’ve seen that you should have at least 50MB/s (write/read). Gregoire has instructions for benchmarking your system in his <a href="https://kauri.io/article/9695fcca217f46feb355245275835fc0">tutorial,</a> if you’re interested in knowing what your hard drive is capable of. In my personal experience, I had a SSD that clocked in at 150MB/s, and I'm not certain that it was enough. It couldn't sync to the tip even after a few months, though I'm not sure if there may have been other factors involed. Good external SSDs can clock in at over 300MB/s, though, so I would recommend doing your research and buying a good, fast drive.</p>
<p>(You may wonder for how long 500GB will be enough. While it’s true that the Ethereum blockchain has grown considerably over time, the amount that each node will need to store should decrease with Eth 2.0/Serenity. As of November 2019, the size of my node is roughly 175 GB. Even if the rate of growth picks up, and Eth 2.0 and sharding don’t arrive for a while, I believe that 500GB should hold out for some time. Of course, there’s nothing wrong with getting a whole TB, especially if you also want to run Swarm.)</p>
<p>As for internet connection, I’m guessing that you need at least 10 Mbits/s in order to not impede using your computer for other stuff. If you’re running on a laptop, and will have a slower connection sometimes, I would assume you could pause running your node while in slower areas, and sync back up when you’re back over 10 Mbits/s.</p>
<p>Lastly, have some patience. Even with all the speedups, the initial sync can easily take more than three days. On the bright side, we’re going to turn this into a background process, so it shouldn’t need much attention from you.</p>
<p>I got through writing this piece before I discovered <a href="https://grid.ethereum.org/">Ethereum Grid,</a> and official Ethereum Foundation project to make an easy-to-use, slick GUI for running nodes, and not just Geth — they’ve preloaded a bunch of different clients, it looks like. Here’s a screenshot from their <a href="https://github.com/ethereum/grid">GitHub</a>:</p>
<p><img alt="" src="https://miro.medium.com/max/1920/1*jT_gnt0ENG-Dd9lDvDZZfw.png" /></p>
<p>I haven’t played around with Grid, and I do not know what the system requirements are, nor how smoothly it’s running. I mean this as no offense whatsoever, but I have found in the blockchain space much as in the rest of the world that the shortcut sometimes takes longer, so you may want to still follow the tutorial and get your node running the ‘hard way’. Even if you are going to use Grid, you may find the instructions below for setting up an external SSD and installing Go useful.</p>
<p>Another reason to run Geth from the command line may be attaching a Swarm node. Grid promises an app store for plugins, and they’re planning for click-and-launch functionality, but they don’t offer it yet (as of Nov. 2019 — feel free to check if anything has changed). It could be that attaching a Swarm node from the command line to Geth runnning on Grid is just as simple as attaching Swarm to a ‘regular’ Geth node, but I, unfortunately don’t know.</p>
<p>With all of those dissuasions, I do want to emphasize that Grid looks super-slick, and is an Ethereum Foundation project. It may be a good place to start, and may even be an easier experience than this tutorial.</p>
<h2 id="setting-up-an-external-ssd"><strong>Setting up an external SSD</strong><a class="headerlink" href="#setting-up-an-external-ssd" title="Permanent link"></a></h2>
<p><em>(Special thanks are in order to</em> <a href="https://twitter.com/gregjeanmart"><em>Gregoire Jeanmart</em></a> <em>— this section is largely copied from his excellent</em> <a href="https://kauri.io/article/9695fcca217f46feb355245275835fc0"><em>tutorial</em></a> <em>for running a node on Raspberry Pi.)</em></p>
<p>If you’re running off an external SSD, here are some steps for setting it up. Use <code>sudo fdisk -l</code> to locate the drive. Here’s an example output from that command:</p>
<pre><code>Disk /dev/sda: 931.5 MiB, 1000204886016 bytes, 1953525168 sectors Disk model: Kingston FF01BT2
Units: sectors of 1 \* 512 = 512 bytes  
Sector size (logical/physical): 512 bytes / 4096 bytes
I/O size (minimum/optimal): 4096 bytes / 4096 bytes  
(...)  
Disk /dev/sdb: 465.8 GiB, 500107862016 bytes, 976773168 sectors  
Disk model: Portable SSD T5 
Units: sectors of 1 \* 512 = 512 bytes  
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
</code></pre>
<p>In this case <code>/dev/sdb</code> is your external SSD. We’ll use this as the example moving forward, so if your SSD is at a different location, replace <code>/dev/sdb</code> with whatever location you gleaned from <code>fdisk</code>.</p>
<p>If you need to (re)partition the drive, use the following. <em>This will wipe everything on the drive.</em> Backup the contents elsewhere and then proceed:</p>
<p><code>sudo mkfs.ext /dev/sdb</code></p>
<p>Press ‘y’ when prompted.</p>
<p>We’re going to manually mount the SSD (replace <code>_user_:_group_</code> with your username and group separated by a colon (:) — if you don’t know about groups, enter <code>groups</code> in the terminal and use the first option):</p>
<pre><code>sudo mkdir /mnt/ssd  
sudo chown -R _user_:_group_ /mnt/ssd
sudo mount /dev/sdb /mnt/ssd
</code></pre>
<p>We want the SSD to auto-mount at startup. Type in <code>sudo blkid</code> and get the <code>UUID</code> associated with the SSD (the one at <code>/dev/sdb</code> or wherever your SSD is). Copy it — we’ll need it in a second.</p>
<p><code>sudo nano /etc/fstab</code></p>
<p>Add the following (make sure to put a space after where you pasted the UUID):</p>
<p><code>UUID=_\*\*Paste UUID from blkid here\*\*_ /mnt/ssd ext4 defaults 0 0</code></p>
<p>Changes won’t take effect without a reboot, so if you want to keep on going and get Geth running, you’ll need to restart. Once you do, you can enter the following to see if the computer did indeed mount the SSD:</p>
<p><code>df -ha /dev/sdb</code></p>
<p>The output should include that <code>/dev/sdb</code> is mounted on <code>/mnt/ssd</code>.</p>
<h2 id="installing-and-setting-up-go">Installing and setting up go<a class="headerlink" href="#installing-and-setting-up-go" title="Permanent link"></a></h2>
<p>We’ll be running Geth, which is an Ethereum client written in Go, so we need to set up Go. The version of Go listed below is the most current version as of this writing, but feel free to check Golang’s <a href="https://golang.org/dl/">site</a> to see if there’s a more current version. We’ll assume a normal 64-bit architecture. If you run into trouble, check the website. Getting Go up and running can be a pain, so we’ll take a shot at simplifying the process:</p>
<pre><code>cd ~/Downloads  
wget https://dl.google.com/go/go1.14.linux-amd64.tar.gz
sudo tar -C /usr/local -xvf go1.14.linux-amd64.tar.gz
</code></pre>
<p><strong>Note:</strong> this assumes <code>go1.14</code> is the latest version of Go (which is the case as of this update (Dec. 8, 2019)). You can check <a href="https://golang.org/dl/">here</a> to see if this is still the case. If there is a newer version, you can remove <code>1.14</code>, replacing it with whatever version is the most current stable.</p>
<p>We need to set the environment variables. There’s more than one way to do this, but here’s one:</p>
<p><code>sudo nano /etc/profile</code></p>
<p>This will open up the Nano text editor on the <code>/etc/profile</code> file. (If you don’t have Nano, <code>sudo apt install nano</code> should do the trick on Debian-like systems. Replace with your friendly neighborhood package manager if you’re on a different Linux.)</p>
<p>At the bottom of the file, add this:</p>
<p><code>export PATH=$PATH:/usr/local/go/bin</code></p>
<p>Press Ctrl+X , hit Y and ENTER to save.</p>
<p><code>sudo source /etc/profile</code></p>
<p>This should get it loaded up. If you type <code>go version</code> in your terminal, you should see something like <code>go version go1.14 linux/arm</code> as the output. If not, you’re in the wonderful world of Go troubleshooting and I wish you luck! You may have to wipe Go and reinstall it, but you can try to find something useful online about the errors you’re getting.</p>
<h2 id="installing-geth">Installing Geth<a class="headerlink" href="#installing-geth" title="Permanent link"></a></h2>
<p>Navigate to whatever folder you want to store the Geth source code in.</p>
<pre><code>export GO111MODULE=on  
go get -d github.com/ethereum/go-ethereum@v1.9.11
\*\*This may take a minute, don't worry  
go install github.com/ethereum/go-ethereum/cmd/geth
</code></pre>
<p><strong>Note:</strong> <code>@1.9.11</code> tells Go to download version 1.9.11, which is the latest stable Geth release as of this update (Mar 6, 2020). You should definitely check <a href="https://geth.ethereum.org/downloads/">here</a> to see what the most recent stable release version number is — it’ll be the one in big print at the top of the page, replacing <code>1.9.11</code> with the version of the most recent stable release.</p>
<p>You may discover various problems with your Go installation at this point. See above, and the wider internet, if this occurs.</p>
<p><code>sudo mv $GOPATH/bin/go-ethereum/build/bin/geth /usr/local/bin</code></p>
<p>Now <code>geth version</code> should output information about your current installation. If it does, congratulations! You installed Geth.</p>
<p>Let’s make a data directory with permissions. (This assumes you’re using an external drive mounted to <code>/mnt/ssd</code>, otherwise replace with the internal location — something like <code>/dev/sda1</code> ):</p>
<pre><code>sudo mkdir /mnt/ssd/ethereum
sudo chown -R _user_:_group_ /mnt/ssd/ethereum
</code></pre>
<h2 id="syncing-with-geth">Syncing with Geth<a class="headerlink" href="#syncing-with-geth" title="Permanent link"></a></h2>
<p>If that all went well, we’re up and running with Geth and syncing.</p>
<p>There’s been a lot of progress in speeding up the initial sync with the current state of the chain, and there’s even cooler stuff being worked on. What this means is that you want to leverage a special syncing mode which should cut down the initial sync to several days. Try the following:</p>
<p><code>geth --syncmode fast --cache 1024--datadir /mnt/ssd/ethereum</code></p>
<p>(If it’s hogging too much memory, try turning down the <code>--cache</code> flag. <code>--cache 256</code> works just fine, but it’ll take a few days to sync, whereas <code>--cache 1024</code> should probably only need a couple of days. At 8GB of RAM my system is unaffected at <code>--cache 256</code>, if that’s of any help.)</p>
<p>If all is well, there should be a pretty solid stream of output. That’s great, but press Ctrl+C to stop it because we’re just checking if it works. We don’t want you to have to manually restart Geth each time you boot up, so we’re going to turn this into a system process (again, copied from Gregoire Jeanmart with permission.)</p>
<p><code>sudo nano /etc/systemd/system/geth.service</code></p>
<p>Once in Nano, type in the following (as before, replace <code>_user_</code> and <code>_group_</code> with your username and group.):</p>
<pre><code>[Unit]  
Description: Geth Node
After=network.target auditd.service  
Wants=network.target

[Service]  
WorkingDirectory=/home/_user_
ExecStart=/usr/local/bin/geth --syncmode fast --cache 256 --datadir mnt/ssd/ethereum  
User=_user_
Group=_group_  
Restart=always
RestartSec=5s

[Install]  
WantedBy=multi-user.target
RequiredBy=swarm.service  
Alias=geth.service
</code></pre>
<p>(Again, the cache above is set at 256. If you are running a dedicated node, or have a lot of RAM, you should probably crank this up to 1024 or even 2048. Also, I would recommend pulling off the <code>--syncmode fast</code> flag once you’ve synced.)</p>
<p>Ctrl+X, then Y and Enter to save changes. The following will reload system daemons, which will now include <code>geth.service</code>, then start <code>geth</code>, then mark this as a service to be launched at startup:</p>
<pre><code>sudo systemctl daemon-reload
sudo systemctl start geth  
sudo systemctl enable geth
</code></pre>
<p>You can check the logs to see if Geth is running:</p>
<p><code>sudo tail -f /var/log/syslog</code></p>
<p>Ctrl+C to get out. Gregoire has great information in his <a href="https://kauri.io/article/9695fcca217f46feb355245275835fc0">tutorial</a> about the nature of syncing (it’s the section called ‘Syncing’) and has a whole other <a href="https://kauri.io/article/5ab5c4d558e04a73accebc652ef2246b">tutorial</a> about how to set up a log and import it into Google Sheets (or similar) with awesome charts. I’d be copying it out word for word, so I’m going to leave you, awesome new node runner, to check it out yourself.</p>
<p><em>Note: the following two sections are meant for when your node has completely synced up, meaning both blocks and states. (See Gregoire’s article for more information.) Syncing state can potentially take a long time. Gregoire seems to have done so in less than four days, whereas I seem to be having a much harder time. Don’t worry! You(r processor) can do it. The next couple of sections are two cool things you can do with a fully synced node.</em></p>
<p><strong>MetaMask</strong></p>
<p>You have your own node now, so you should do awesome cool things with it. The first thing we’ll work on is decentralizing your MetaMask. (You should get <a href="https://metamask.io/">MetaMask</a> if you don’t have it already.) You see, MetaMask works out of the box by connecting to Infura, which is sort of a giant node some people run so that other people can query it. In other words, you have to trust Infura, and we’re way too cypherpunk to do that when we totally don’t need to. (No offense, Infura, you’re awesome.) You’ve got a node on your machine, so it’s rather silly to go calling Infura for information, anyway.</p>
<p>Exactly how to do this depends on your browser. (<a href="https://ethereum.stackexchange.com/a/77032/27270">Here’s an answer</a> from StackExchange this section is based on.) The basic idea is that Geth needs to be open to cross-domain RPC requests from the MetaMask extension in the browser. You’ll need to open up <code>geth.service</code> again — <code>sudo nano /etc/systemd/system/geth.service</code>, and add to <code>ExecStart</code>.</p>
<h2 id="chromebrave"><strong>Chrome/Brave</strong><a class="headerlink" href="#chromebrave" title="Permanent link"></a></h2>
<p><code>--rpc --rpccorsdomain="chrome-extension://nkbihfbeogaeaoehlefnkodbefgpgknn"</code></p>
<p>If that doesn’t work, you may need to follow a similar process to what we’ll describe in Firefox and Tor. Search for how to get a Chrome extension ID.</p>
<h2 id="firefoxtor"><strong>Firefox/Tor</strong><a class="headerlink" href="#firefoxtor" title="Permanent link"></a></h2>
<p>First, make sure that you have MetaMask, and that it’s not disabled (you can go to <code>about:addons</code> in the URL bar to see). Open a new tab, and type <code>about:memory</code> in the URL. Click measure in <strong>Show memory reports</strong>. Scroll down to <strong>Other Measurements</strong>, where there’s a section for browser extensions. (Or just hit CTRL+F and search for <code>metamask</code>.) You should see something like the following, but all on one line (formatting problems again):</p>
<p><code>Extension([id=webextension@metamask.io](mailto:id=webextension@metamask.io), name="MetaMask", baseURL=moz-extension://f3a66ea7-df4d-4731-80db-de45a4abebd6/</code></p>
<p><em>(Brought to you by</em> <a href="https://stackoverflow.com/a/51283520/7913944"><em>this</em></a> <em>answer on StackOverflow.)</em></p>
<p>Using <code>f3a66ea7-df4d-4731-80db-de45a4abebd6</code> as our example <code>moz-extension</code>, add the following to <code>ExecStart</code> in <code>/etc/systemd/system/geth.service</code>:</p>
<p><code>--rpc --rpccorsdomain="moz-extension://f3a66ea7-df4d-4731-80db-de45a4abebd6"</code></p>
<p>You’ll need to reload Geth for the changes to take effect:</p>
<p><code>sudo restart geth</code></p>
<p>Now to MetaMask. Open up MetaMask, and in the <strong>Networks</strong> menu, select <strong>Localhost 8545</strong>. MetaMask should connect to your node and you’re browsing Web3 using your own node!</p>
<p><strong>Swarm</strong></p>
<p>Swarm is part of the platform of technologies that Ethereum is a part of. It is a system for decentralized storage, much like IPFS. Once you have Geth synced with the chain, you should go the extra mile and configure Swarm. Eventually, the goal is that hosting data will generate profit (think of it as renting out your hard drive space), but don’t expect to see any profit any time soon. Then again, you have extra space on your spiffy SSD, so let’s do it:</p>
<pre><code>go get -d github.com/ethersphere/swarm@v0.5.7
go install github.com/ethersphere/swarm/cmd/swarm
</code></pre>
<p>This assumes <code>0.5.7</code> is the latest stable release (and also that the <code>GO111MODULE</code> is set to <code>on</code>, you can type <code>export GO111MODULE=on</code> in your shell if it’s not). Check <a href="https://swarm-gateways.net/bzz:/swarm.eth/downloads/">here</a> what the latest stable release is, and replace <code>0.5.7</code> with the most current stable release version.</p>
<p>Let’s move the Swarm executable into your <code>bin</code> so that you can call it from the command line without the whole path, just like we did for Geth. I can’t guarantee that your setup is the same as mine, but here’s what I did:</p>
<p><code>sudo mv $GOPATH/bin/swarm /usr/local/bin</code></p>
<p>If that fails, look around in the Go directory (you can type <code>echo $GOPATH</code> to find it) to find where the Swarm executable is.</p>
<p>You should be able to type <code>swarm version</code> in the console and get an output. You’ll need an account registered by your Geth node:</p>
<p><code>geth account new --datadir /mnt/ssd/ethereum</code></p>
<p><em>This assumes you are using the location</em> <code>_/mnt/ssd/ethereum_</code> <em>for your node, as per the directions for attaching an external SSD above. If you are using a different location, put that after</em> <code>_--datadir_</code> <em>instead, and if you’re using the default location, leave the</em> <code>_--datadir_</code> <em>flag off entirely.</em></p>
<p>You’ll be prompted for a passphrase. It’s important that you remember this passphrase, as there’s no way to recover it if lost. Copy the output into a file in a clever location with a clever name (do not necessarily use the path and filename below), we’ll need this file soon:</p>
<p><code>touch _~/path/to/data.txt_</code></p>
<p>(The file does not need to end in <code>txt</code>, to the best of my knowledge.) You’ll probably want to restrict permissions to this.</p>
<p>Copy the passphrase into the file. Again, we’ll need this soon.</p>
<h2 id="a-word-on-full-and-light-swarm-nodes">A word on full and light Swarm nodes<a class="headerlink" href="#a-word-on-full-and-light-swarm-nodes" title="Permanent link"></a></h2>
<p>Before we get started, a quick word. Swarm, like Ethereum has a concept of full and light nodes. A full node is expected to be online pretty much all the time, so that it can serve the content that it’s storing. That means that if you’re running on a laptop, you’ll probably want to be running a light node. You’ll be able to receive content from Swarm, but won’t have the expectation of being available to serve. If this is the case, add the flag <code>--lightnode</code> to any commands starting with <code>swarm</code> here.</p>
<p><code>swarm --bzzaccount _\*\*Paste address\*\*_</code></p>
<p>You’ll be prompted for your passphrase. Paste it in, and the output should confirm that Swarm is running but — even cooler — if you point your browser to <a href="http://localhost:8500/">http://localhost:8500</a> you should see the Swarm gateway. Don’t worry if you can’t use an .eth domain, it’s because we haven’t configured ENS yet.</p>
<p>If you are seeing errors, don’t be discouraged. They don’t necessarily mean that the node isn’t working. I was getting a really heavy stream of errors of the following three varieties, and I was told I could safely ignore them, and that they will be taken out of end-user logs in the future:</p>
<pre><code>ERROR netstore. Get can not retrieve chunk  
ERROR not forwarding request, origin node is closer to chunk than this node base
ERROR dropping peer with DiscSubprotocolError
</code></pre>
<p>(I may have only gotten the third when I was closing the node.)</p>
<p>Ctrl+C out, since we’re going to turn this into a system process too:</p>
<pre><code>sudo nano /etc/systemd/system/swarm.service
</code></pre>
<p>Once in Nano, add the following. Replace <code>_user_</code> and <code>_group_</code> with your username and group, as you did for <code>geth.service</code>, and put in the address you generated in Geth for <code>address</code>, along with the path to the file with your password using the <code>--password</code> flag.</p>
<pre><code>[Unit]
Description=Swarm Node  
After=network.target auditd.service
Wants=network.target  
Requires=geth.service

[Service]
WorkingDirectory=/home/_user_  
ExecStart=swarm --ens-api /mnt/ssd/ethereum/geth.ipc --bzzaccount _address_ \--password _/path/to/password.txt_
User=_user_  
Group=_group_
Restart=always  
RestartSec=5s

[Install]
WantedBy=multi-user.target  
Alias=swarm.service
</code></pre>
<p><em>If you restricted permissions to the password file, make sure the service has the proper permissions to access it.</em></p>
<p>You’ll see that we’ve added ENS support. My experience is that it's really only worth it to run a Swarm node until you've synced the state (not just headers) from the chain. There isn't stable functionality until you've synced the state, and I've had experience with Swarm having spikes in consumption (maybe this is only a thing when you're running it with an unsynced client, though.)</p>
<p>If you want to know where you’re up to with syncing your Geth node, you can use the Geth console (<code>geth attach /mnt/ssd/ethereum/geth.ipc</code>, or whatever your path is), and type in <code>eth.syncing</code>. If it returns <code>false</code>, you’re all synced up on states. Otherwise you’ll get an object with some data. It's hard to know what percentage of the states you have (you can look up blocks on Etherscan), though.</p>
<p>We’re a few quick commands from loading, starting, and getting our service to start on startup:</p>
<pre><code>sudo systemctl daemon-reload
sudo systemctl start swarm  
_You shouldn't do the next one until you're ready for Swarm to autolaunch at startup_
sudo systemctl enable swarm
</code></pre>
<p>Congratulations — you are mightily contributing to a decentralized web in the background of your computer!</p>
<h3 id="_1"><a class="headerlink" href="#_1" title="Permanent link"></a></h3>
<hr />
<ul>
<li><strong>Kauri original title:</strong> Run an Ethereum node on Debian with an External SSD (Mar 2020)</li>
<li><strong>Kauri original link:</strong> https://kauri.io/run-an-ethereum-node-on-debian-with-an-external-ss/a73723dd2e924d8c948923709763f409/a</li>
<li><strong>Kauri original author:</strong> William (@wschwab)</li>
<li><strong>Kauri original Publication date:</strong> 2020-03-08</li>
<li><strong>Kauri original tags:</strong> metamask, geth, nodes, swarm, systemd, debian</li>
<li><strong>Kauri original hash:</strong> QmczpCVLAjrXRV7smmvCoNvhj7cx497QFk3dNWfBTXp7Ry</li>
<li><strong>Kauri original checkpoint:</strong> QmZUeDv5bCt7vrRCQbwPMQf812VWip98dcsMJHdYdaiQ3d</li>
</ul>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../ethereum-on-arm.-turn-your-arm-device-into-a-full/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../ethereum-on-arm.-turn-your-arm-device-into-a-full/" class="btn btn-xs btn-link">
        Ethereum on ARM. Turn your ARM device into a full Ethereum node just by flashing a MicroSD card
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../Java%20Ethereum/connecting-to-an-ethereum-client-with-java-eclips/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../Java%20Ethereum/connecting-to-an-ethereum-client-with-java-eclips/" class="btn btn-xs btn-link">
        Connecting to an Ethereum client with Java, Eclipse and Web3j
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
      <p>
        <a href="https://github.com/kauri-io/archive/edit/main/docs/communities/Ethereum Node Runners/run-an-ethereum-node-on-debian-with-an-external-s.md"><i class="fa fa-github"></i>
Edit on GitHub</a>
      </p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>
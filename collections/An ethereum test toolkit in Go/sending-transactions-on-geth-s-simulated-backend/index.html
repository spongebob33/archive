<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://kauri.io/collections/An%20ethereum%20test%20toolkit%20in%20Go/sending-transactions-on-geth-s-simulated-backend/">
    <link rel="shortcut icon" href="../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Sending Transactions on GETH's Simulated Backend - kauri.io</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Sending Transactions on GETH's Simulated Backend", url: "#_top", children: [
              {title: "Sending a transaction", url: "#sending-a-transaction" },
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-172017815-1', 'kauri.io');
        ga('send', 'pageview');
    </script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    <h1 id="sending-transactions-on-geths-simulated-backend">Sending Transactions on GETH's Simulated Backend<a class="headerlink" href="#sending-transactions-on-geths-simulated-backend" title="Permanent link"></a></h1>
<p>Now that we have a contract deployed, we want to interact with it.</p>
<p>In the last session there was some interaction without any explanation. This time we will go a bit deeper.</p>
<p>As you should be aware, there are several types of interaction with the ethereum blockchain (not including mining).</p>
<p>The main ones are</p>
<ol>
<li>Sending a Transaction</li>
<li>Reading the state of the blockchain or a transaction</li>
<li>Requesting Data about the current state of a contract</li>
<li>Viewing events that were generated by interactions with a contract</li>
</ol>
<h3 id="sending-a-transaction">Sending a transaction<a class="headerlink" href="#sending-a-transaction" title="Permanent link"></a></h3>
<p>Sending a transaction involves your client to add the transaction to its transaction pool and propagate it to its peers so that it can be be included in a block. This requires the transaction to be mined and the entire network to reach a state of consensus.</p>
<p>This can take time so you cannot expect an immediate reply as to whether your transaction has succeeded or failed.</p>
<p>Transactions must be signed by the originator of the transaction and must be paid for (in gas).</p>
<p>All of these operations involve sending transactions</p>
<ol>
<li>Sending ETH to another address</li>
<li>Deploying a contract</li>
<li>Calling a function or method in a contract</li>
</ol>
<h4 id="sending-eth">Sending ETH<a class="headerlink" href="#sending-eth" title="Permanent link"></a></h4>
<p>Sending any transaction requires that we form a transaction and get it signed before submitting it.</p>
<p>A transaction can be created by the NewTransaction function found in the GETH repo under <code>/core/types</code></p>
<pre><code class="language-go">func NewTransaction(nonce uint64, to common.Address, amount *big.Int, gasLimit uint64, gasPrice *big.Int, data []byte) *Transaction
</code></pre>
<p>Let's go through these</p>
<p><code>nonce</code> : a serial number tied to the sending account. This is used to ensure that no transaction can be processed twice. Transactions from an account are processed in order of the nonce. Even if you submit Tx #4 before Tx #3, it will not be processed until #3 has been processed.</p>
<p>You can obtain the nonce using <code>client.PendingNonceAt</code> from the client library that you are using e.g. ethclient.</p>
<p><code>amount</code> : the amount of ETH (in wei) that want to transfer. This can be ZERO if you are calling a transaction or merely signalling that you control the keys to an address.</p>
<p><code>data</code> : when sending ETH to a non contract address this is rarely used (it can be used to convey information). When deploying or talking to a contract it contains the contract's byte code or a function signature and parameters</p>
<p><code>gasLimit</code> : As you should be aware, fees (paid in eth) are termed <code>gas</code>. The amount of gas to be paid depends on the amount of work to be done and the amount of storage used. <code>client.EstimateGas</code> can help you estimate how much gas needs to be paid for the transaction. If you are sending ETH to a normal address (not a contract) the amount of gas is currently fixed at 2100 but there is no guarantee that this will always be the case. If you set the gas limit too high, you will normally get a refund for unused gas.</p>
<p><code>gasPrice</code> : Your transaction needs to get mined in order to have any effect. When the network is busy, everybody is competing to get their transaction mined - so they offer more incentive to the miners in terms of gas price which is rated in GWei (1 million Wei). In general, transactions with higher gas prices tend to get mined first but there is no guarantee. </p>
<p>The cost of the transaction can be calculated as <code>gasLimit x gasPrice</code> So, a transaction sent with a gasLimit of 200,000 and a gasPrice of 10 GWei could cost up to 200,000 x 10,000,000,000 Wei = 2 x 10^15 Wei = 0.002 ether</p>
<p>You can get current average gas prices from https://ethgasstation.io the transaction cost calculator is at https://ethgasstation.info/calculatorTxV.php</p>
<p>Now you have a transaction, you need to sign it. For the simulated back end we will use the homestead signer. For mainnet you will probably need to use an EIP155Signer.</p>
<pre><code class="language-go">  senderKey,_ := memorykeys.GetPrivateKey()
  s := types.HomesteadSigner{}
  tx, err := types.SignTx(t, s, senderKey
  if err != nil {
    return nil, err
  }
</code></pre>
<p>Now you have a signed transaction, you need to submit it to the network</p>
<pre><code class="language-go">  err = client.SendTransaction(context.Background(), tx)
</code></pre>
<p>You now need to wait for the transaction to be mined - or in the simulated backend you call <code>client.Commit()</code></p>
<p>On the simulatedBackend you can simply call <code>client.Commit()</code></p>
<p>On the main / test nets you need to either wait for it to be mined using <code>bind.WaitMined(context, client, transaction)</code> or check the transaction receipt yourself until it shows that it has been executed.</p>
<h4 id="deploying-a-contract">Deploying a contract<a class="headerlink" href="#deploying-a-contract" title="Permanent link"></a></h4>
<p>In a previous post we have covered deploying a contract using ABIGEN.</p>
<pre><code class="language-go">  auctionAddress, tx, auctionContract, err := contracts.DeployAuction(bankTx, client, startBids, endBids, startReveal, endReveal, minimumBid, *wallet)
</code></pre>
<p>We could deploy a contract by compiling it using solc, getting the deploycode then using that as the data in a transaction but the wrapped contract makes it a lot easier.</p>
<h4 id="interacting-with-the-contract">Interacting with the contract<a class="headerlink" href="#interacting-with-the-contract" title="Permanent link"></a></h4>
<p>As you should know, there are two ways to interact with a contract</p>
<ol>
<li>Enquiring the state of the contract</li>
<li>Attempting to interact with the contract in a way that changes the state of the contract or the blockchain</li>
</ol>
<p>Since we know that each fully synced node contains an exact complete copy of the EVM state, we can ask ANY node to tell us the state of a contract. Most enquiries do not need to know who sent the enquiry so the request usually need not be signed.</p>
<p>Changing that state, on the other hand, requires that the transaction be transmitted to the network and a consensus be reached. This requires a signed transaction, gas and takes an uncertain amount of time.</p>
<p>Both, however, can be easily handled by ABIGEN which creates wrappers for all functions.</p>
<h5 id="making-a-request">Making a request<a class="headerlink" href="#making-a-request" title="Permanent link"></a></h5>
<p>Most of the time that you request information from a contract, the function you are calling will not require any information from the transaction (sender, amount, gasPrice, gasLimit) in which case ABIGEN allows you to use <code>nil</code> as the transaction operator.</p>
<pre><code class="language-go">min, err := auctionContract.MinimumBid(nil)
</code></pre>
<p>If the function required the sender's address you need to supply a bind.CallOpts structure</p>
<h5 id="changing-the-state">Changing the state<a class="headerlink" href="#changing-the-state" title="Permanent link"></a></h5>
<p>We have already submitted one transaction that changes the state when we deployed the contract. Let's look at that in a bit more detail.</p>
<p>We used the <code>memorykeys</code> module to get a transactor</p>
<pre><code class="language-go">bankTx, _ := memorykeys.GetTransactor(&quot;banker&quot;)
</code></pre>
<p>The GetTransactor function in memorykeys uses a function in the bind module <code>NewKeyedTransactor</code> to create a transactor that can be used to sign transactions</p>
<pre><code class="language-go">func GetTransactor(keyName string) (*bind.TransactOpts, error) {
    key, err := GetPrivateKey(keyName)
    if err != nil {
        return nil, err
    }
    return bind.NewKeyedTransactor(key), nil
}
</code></pre>
<p>This can then be used to deploy a contract (as seen before) or send transactions to it.</p>
<p>So in the continued context of the Devcon5 Auction Contract, first we make a call to get the hash of our chosen phrase</p>
<pre><code class="language-go">    hash, err := auctionContract.CalculateHash(nil, minimumBid, []byte(&quot;mary had a little lamb&quot;))
    if err != nil {
        fmt.Println(err)
        os.Exit(1)
    }
</code></pre>
<p>Then we use that hash and send our bid (assuming that the account <code>user01</code> has been funded with ETH)</p>
<pre><code class="language-go">    userTx, _ := memorykeys.GetTransactor(&quot;user01&quot;)
    userTx.Value = minimumBid
    tx, err = auctionContract.BiddingTime(userTx, hash)
    if err != nil {
        fmt.Println(&quot;bid : &quot;, err)
        os.Exit(1)
    }
    client.Commit()
</code></pre>
<hr />
<p>SendEth code</p>
<pre><code class="language-go">func sendEth(ec bind.ContractTransactor, sender string, recipient string, amount *big.Int, gasLimit uint64) (*types.Transaction, error) {
  senderKey, _ := memorykeys.GetPrivateKey(sender)
  senderAddress, _ := memorykeys.GetAddress(sender)
  recipientAddress, _ := memorykeys.GetAddress(recipient)
  nonce, err := ec.PendingNonceAt(context.Background(), *senderAddress)
  if err != nil {
    return nil, err
  }
  gasPrice, err := ec.SuggestGasPrice(context.Background())
  if err != nil {
    return nil, err
  }
  s := types.HomesteadSigner{}
  data := common.FromHex(&quot;0x&quot;)
  t := types.NewTransaction(nonce, *recipientAddress, amount, gasLimit, gasPrice, data)
  tx, err := types.SignTx(t, s, senderKey)
  if err != nil {
    return nil, err
  }
  err = ec.SendTransaction(context.Background(), tx)
  return tx, err
}
</code></pre>
<p>Main code</p>
<pre><code class="language-go">func main() {
  client, err := getClient()
  if err != nil {
    log.Fatal(err)
  }
  startBids := getTime(&quot;13/09/19&quot;)
  endBids := getTime(&quot;15/09/19&quot;)
  startReveal := endBids
  endReveal := getTime(&quot;17/09/19&quot;)
  minimumBid, _ := etherUtils.StrToEther(&quot;4.7&quot;)
  wallet, _ := memorykeys.GetAddress(&quot;wallet&quot;)
  bankTx, _ := memorykeys.GetTransactor(&quot;banker&quot;)
  txes := make(map[string]*types.Transaction)
  for user := 0; user &lt; 100; user++ {
    userID := fmt.Sprintf(&quot;user%02d&quot;, user)
    txes[userID], _ = sendEth(client, &quot;banker&quot;, userID, new(big.Int).Add(minimumBid, etherUtils.OneEther()), 21000)
  }
  auctionAddress, tx, auctionContract, err := contracts.DeployAuction(bankTx, client, startBids, endBids, startReveal, endReveal, minimumBid, *wallet)
  chkerr(err)
  fmt.Println(auctionAddress.Hex(), tx.Hash().Hex())
  client.Commit()
  min, err := auctionContract.MinimumBid(nil)
  chkerr(err)
  fmt.Println(&quot;minumum bid is &quot;, etherUtils.EtherToStr(min))
  fmt.Println(&quot;time :&quot;, currentTime())
  isBiddingOpen(auctionContract)
  jumpTo(startBids)
  fmt.Println(&quot;time :&quot;, currentTime())
  isBiddingOpen(auctionContract)
  userTx, _ := memorykeys.GetTransactor(&quot;user01&quot;)
  hash, err := auctionContract.CalculateHash(nil, minimumBid, []byte(&quot;mary had a little lamb&quot;))
  if err != nil {
    fmt.Println(err)
    os.Exit(1)
  }
  userTx.Value = minimumBid
  tx, err = auctionContract.BiddingTime(userTx, hash)
  if err != nil {
    fmt.Println(&quot;bid : &quot;, err)
    os.Exit(1)
  }
  client.Commit()
  contractBalance, _ := client.BalanceAt(context.Background(), auctionAddress, nil)
  userAddress, _ := memorykeys.GetAddress(&quot;user01&quot;)
  userBalance, _ := client.BalanceAt(context.Background(), *userAddress, nil)
  fmt.Println(&quot;User Balance &quot;, etherUtils.EtherToStr(userBalance))
  fmt.Println(&quot;Auction Balance &quot;, etherUtils.EtherToStr(contractBalance))
}
</code></pre>
<p>You can find the code and articles in github at</p>
<p><code>https://github.io/DaveAppleton/testEnvArticle</code></p>
<hr />
<ul>
<li><strong>Kauri original title:</strong> Sending Transactions on GETH's Simulated Backend</li>
<li><strong>Kauri original link:</strong> https://kauri.io/sending-transactions-on-geths-simulated-backend/282ffccc00104339823222f239d949ee/a</li>
<li><strong>Kauri original author:</strong> Dave Appleton (@daveappleton)</li>
<li><strong>Kauri original Publication date:</strong> 2019-10-01</li>
<li><strong>Kauri original tags:</strong> ethereum, geth, testing</li>
<li><strong>Kauri original hash:</strong> QmTmmYK6DdTkpbBtgv5HjCVFkfK8XDnctAXW12Z8vQR8Yd</li>
<li><strong>Kauri original checkpoint:</strong> QmYRYAA1TRyDiXS6uLXdt6qS8AnW63tqJHYpUQKrdyNz7h</li>
</ul>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../interacting-with-smart-contracts-from-geth-s-simu/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../interacting-with-smart-contracts-from-geth-s-simu/" class="btn btn-xs btn-link">
        Interacting with smart contracts from GETH's Simulated Backend
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../../A%20non%20practitioner%20guide%20to%20machine%20learning%20/multi-class-classification-example-with-convoluti/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../../A%20non%20practitioner%20guide%20to%20machine%20learning%20/multi-class-classification-example-with-convoluti/" class="btn btn-xs btn-link">
        Multi-class classification example with Convolutional Neural Network in Keras and Tensorflow
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
      <p>
        <a href="https://github.com/kauri-io/archive/edit/main/docs/collections/An ethereum test toolkit in Go/sending-transactions-on-geth-s-simulated-backend.md"><i class="fa fa-github"></i>
Edit on GitHub</a>
      </p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <link rel="canonical" href="https://kauri.io/collections/Bitcoin/bitcoin-contract-scripts/">
    <link rel="shortcut icon" href="../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Bitcoin Contract Scripts - kauri.io</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Bitcoin Contract Scripts", url: "#_top", children: [
              {title: "Introduction", url: "#introduction" },
              {title: "Escrow And Arbitration", url: "#escrow-and-arbitration" },
              {title: "Micropayment Channel", url: "#micropayment-channel" },
              {title: "CoinJoin", url: "#coinjoin" },
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-172017815-1', 'kauri.io');
        ga('send', 'pageview');
    </script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    <h1 id="bitcoin-contract-scripts">Bitcoin Contract Scripts<a class="headerlink" href="#bitcoin-contract-scripts" title="Permanent link"></a></h1>
<p><img alt="" src="https://ipfs.infura.io/ipfs/QmbBbyyLyLQs2S59sn2w65cEjP1w5nnnaSiCCZsWHjQWGp" /></p>
<p><em>This post originally appeared on <a href="https://bitcoin.org/en/contracts-guide#introduction">bitcoin.org</a></em></p>
<h3 id="introduction">Introduction<a class="headerlink" href="#introduction" title="Permanent link"></a></h3>
<p>The following subsections will describe a variety of Bitcoin contracts
already in use. Because contracts deal with real people, not just
transactions, they are framed below in story format.</p>
<p>Besides the contract types described below, many other contract types
have been proposed. Several of them are collected on the <a href="https://en.bitcoin.it/wiki/Contracts">Contracts
page</a> of the Bitcoin Wiki.</p>
<h3 id="escrow-and-arbitration">Escrow And Arbitration<a class="headerlink" href="#escrow-and-arbitration" title="Permanent link"></a></h3>
<p>Charlie-the-customer wants to buy a product from Bob-the-businessman,
but neither of them trusts the other person, so they use a contract to
help ensure Charlie gets his merchandise and Bob gets his payment.</p>
<p>A simple contract could say that Charlie will spend satoshis to an
output which can only be spent if Charlie and Bob both sign the input
spending it. That means Bob won't get paid unless Charlie gets his
merchandise, but Charlie can't get the merchandise and keep his payment.</p>
<p>This simple contract isn't much help if there's a dispute, so Bob and
Charlie enlist the help of Alice-the-arbitrator to create an <a href="https://bitcoin.org/en/glossary/escrow-contract">escrow
contract</a>. Charlie spends his satoshis
to an output which can only be spent if two of the three people sign the
input. Now Charlie can pay Bob if everything is ok, Bob can refund
Charlie's money if there's a problem, or Alice can arbitrate and decide
who should get the satoshis if there's a dispute.</p>
<p>To create a multiple-signature (<a href="https://bitcoin.org/en/glossary/multisig">multisig</a>
output, they each give the others a public key. Then Bob creates the
following <a href="https://bitcoin.org/en/glossary/redeem-script">P2SH multisig</a> redeem script:</p>
<pre><code>OP_2 [A's pubkey] [B's pubkey] [C's pubkey] OP_3 OP_CHECKMULTISIG
</code></pre>
<p>(Opcodes to push the public keys onto the stack are not shown.)</p>
<p><code>OP_2</code> and <code>OP_3</code> push the actual numbers 2 and 3 onto the
stack. <code>OP_2</code>
specifies that 2 signatures are required to sign; <code>OP_3</code> specifies that
3 public keys (unhashed) are being provided. This is a 2-of-3 multisig
pubkey script, more generically called a m-of-n pubkey script (where <em>m</em> is the
<em>minimum</em> matching signatures required and <em>n</em> in the <em>number</em> of public
keys provided).</p>
<p>Bob gives the redeem script to Charlie, who checks to make sure his
public key and Alice's public key are included. Then he hashes the
redeem script to create a P2SH redeem script and pays the satoshis to it. Bob
sees the payment get added to the block chain and ships the merchandise.</p>
<p>Unfortunately, the merchandise gets slightly damaged in transit. Charlie
wants a full refund, but Bob thinks a 10% refund is sufficient. They
turn to Alice to resolve the issue. Alice asks for photo evidence from
Charlie along with a copy of the redeem script Bob created and
Charlie checked.</p>
<p>After looking at the evidence, Alice thinks a 40% refund is sufficient,
so she creates and signs a transaction with two outputs, one that spends 60%
of the satoshis to Bob's public key and one that spends the remaining
40% to Charlie's public key.</p>
<p>In the signature script Alice puts her signature
and a copy of the unhashed serialized redeem script
that Bob created.  She gives a copy of the incomplete transaction to
both Bob and Charlie.  Either one of them can complete it by adding
his signature to create the following signature script:</p>
<pre><code>OP_0 [A's signature] [B's or C's signature] [serialized redeem script]
</code></pre>
<p>(Opcodes to push the signatures and redeem script onto the stack are
not shown. <code>OP_0</code> is a workaround for an off-by-one error in the original
implementation which must be preserved for compatibility.  Note that
the signature script must provide signatures in the same order as the
corresponding public keys appear in the redeem script.  See the description in
<a href="https://bitcoin.org/en/developer-reference#term-op-checkmultisig"><code>OP_CHECKMULTISIG</code></a> for details.)</p>
<p>When the transaction is broadcast to the network, each peer checks the
signature script against the P2SH output Charlie previously paid,
ensuring that the redeem script matches the redeem script hash previously
provided. Then the redeem script is evaluated, with the two signatures
being used as input<!--noref--> data. Assuming the redeem script
validates, the two transaction outputs show up in Bob's and Charlie's
wallets as spendable balances.</p>
<p>However, if Alice created and signed a transaction neither of them would
agree to, such as spending all the satoshis to herself, Bob and Charlie
can find a new arbitrator and sign a transaction spending the satoshis
to another 2-of-3 multisig redeem script hash, this one including a public
key from that second arbitrator. This means that Bob and Charlie never
need to worry about their arbitrator stealing their money.</p>
<p><strong>Resource:</strong> <a href="https://www.bitrated.com/">BitRated</a> provides a multisig arbitration
service interface using HTML/JavaScript on a GNU AGPL-licensed website.</p>
<h3 id="micropayment-channel">Micropayment Channel<a class="headerlink" href="#micropayment-channel" title="Permanent link"></a></h3>
<!-- SOMEDAY: try to rewrite using a more likely real-world example without
making the text or illustration more complicated -->

<p>Alice also works part time moderating forum posts for Bob. Every time
someone posts to Bob's busy forum, Alice skims the post to make sure it
isn't offensive or spam. Alas, Bob often forgets to pay her, so Alice
demands to be paid immediately after each post she approves or rejects.
Bob says he can't do that because hundreds of small payments will cost
him thousands of satoshis in transaction fees, so Alice suggests they use a
<a href="https://bitcoin.org/en/contracts-guide#term-micropayment-channel">micropayment channel</a>.</p>
<p>Bob asks Alice for her public key and then creates two transactions.
The first transaction pays 100 millibitcoins to a P2SH output whose
2-of-2 multisig redeem script requires signatures from both Alice and Bob.
This is the bond transaction.
Broadcasting this transaction would let Alice hold the millibitcoins
hostage, so Bob keeps this transaction private for now and creates a
second transaction.</p>
<p>The second transaction spends all of the first transaction's millibitcoins
(minus a transaction fee) back to Bob after a 24 hour delay enforced
by locktime. This is the refund transaction. Bob can't sign the refund transaction by himself, so he gives
it to Alice to sign, as shown in the
illustration below.</p>
<p><img alt="" src="https://ipfs.infura.io/ipfs/QmP8xFKxMZbunPPthQXw2CGzEaeDYwKHBwezchkXSNdEDv" /></p>
<p>Alice checks that the refund transaction's locktime is 24 hours in the
future, signs it, and gives a copy of it back to Bob. She then asks Bob
for the bond transaction and checks that the refund transaction spends
the output of the bond transaction. She can now broadcast the bond
transaction to the network to ensure Bob has to wait for the time lock
to expire before further spending his millibitcoins. Bob hasn't actually
spent anything so far, except possibly a small transaction fee, and
he'll be able to broadcast the refund transaction in 24 hours for a
full refund.</p>
<p>Now, when Alice does some work worth 1 millibitcoin, she asks Bob to create
and sign a new version of the refund transaction.  Version two of the
transaction spends 1 millibitcoin to Alice and the other 99 back to Bob; it does
not have a locktime, so Alice can sign it and spend it whenever she
wants.  (But she doesn't do that immediately.)</p>
<p>Alice and Bob repeat these work-and-pay steps until Alice finishes for
the day, or until the time lock is about to expire.  Alice signs the
final version of the refund transaction and broadcasts it, paying
herself and refunding any remaining balance to Bob.  The next day, when
Alice starts work, they create a new micropayment channel.</p>
<p>If Alice fails to broadcast a version of the refund transaction before
its time lock expires, Bob can broadcast the first version and receive a
full refund. This is one reason micropayment channels are best suited to
small payments---if Alice's Internet service goes out for a few hours
near the time lock expiry, she could be cheated out of her payment.</p>
<p>Transaction malleability, discussed above in the Transactions section,
is another reason to limit the value of micropayment channels.
If someone uses transaction malleability to break the link between the
two transactions, Alice could hold Bob's 100 millibitcoins hostage even if she
hadn't done any work.</p>
<p>For larger payments, Bitcoin transaction fees are very low as a
percentage of the total transaction value, so it makes more sense to
protect payments with immediately-broadcast separate transactions.</p>
<p><strong>Resource:</strong> The <a href="http://bitcoinj.github.io/">bitcoinj</a> Java library
provides a complete set of micropayment functions, an example
implementation, and <a href="https://bitcoinj.github.io/working-with-micropayments">a
tutorial</a>
all under an Apache license.</p>
<h3 id="coinjoin">CoinJoin<a class="headerlink" href="#coinjoin" title="Permanent link"></a></h3>
<p>Alice is concerned about her privacy. She knows every transaction gets
added to the public block chain, so when Bob and Charlie pay her, they
can each easily track those satoshis to learn what Bitcoin
addresses she pays, how much she pays them, and possibly how many
satoshis she has left.</p>
<p>Alice isn't a criminal, she just wants plausible deniability about
where she has spent her satoshis and how many she has left, so she
starts up the Tor anonymity service on her computer and logs into an
IRC chatroom as "AnonGirl."</p>
<p>Also in the chatroom are "Nemo" and "Neminem." They collectively
agree to transfer satoshis between each other so no one besides them
can reliably determine who controls which satoshis. But they're faced
with a dilemma: who transfers their satoshis to one of the other two
pseudonymous persons first? The CoinJoin-style contract, shown in the
illustration below, makes this decision easy: they create a single
transaction which does all of the spending simultaneously, ensuring none
of them can steal the others' satoshis.</p>
<p><img alt="" src="https://ipfs.infura.io/ipfs/QmYAyCrUnQJ2xr6G3UKWcUSiyGeaEteVHNpqy8eYebi3Mf" /></p>
<p>Each contributor looks through their collection of Unspent Transaction
Outputs (UTXOs) for 100 millibitcoins they can spend. They then each generate
a brand new public key and give UTXO details and pubkey hashes to the
facilitator. In this case, the facilitator is AnonGirl; she creates
a transaction spending each of the UTXOs to three equally-sized outputs.
One output goes to each of the contributors' pubkey hashes.</p>
<p>AnonGirl then signs her inputs using <code>SIGHASH_ALL</code> to ensure nobody can
change the input or output details.  She gives the partially-signed
transaction to Nemo who signs his inputs the same way and passes it
to Neminem, who also signs it the same way. Neminem then broadcasts
the transaction to the Bitcoin peer-to-peer network, mixing all of the millibitcoins in
a single transaction.</p>
<p>As you can see in the illustration, there's no way for anyone besides
AnonGirl, Nemo, and Neminem to confidently determine who received
which output, so they can each spend their output with plausible
deniability.</p>
<p>Now when Bob or Charlie try to track Alice's transactions through the
block chain, they'll also see transactions made by Nemo and
Neminem. If Alice does a few more CoinJoins, Bob and Charlie might
have to guess which transactions made by dozens or hundreds of people
were actually made by Alice.</p>
<p>The complete history of Alice's satoshis is still in the block chain,
so a determined investigator could talk to the people AnonGirl
CoinJoined with to find out the ultimate origin of her satoshis and
possibly reveal AnonGirl as Alice. But against anyone casually browsing
block chain history, Alice gains plausible deniability.</p>
<p>The CoinJoin technique described above costs the participants a small
amount of satoshis to pay the transaction fee. An alternative
technique, purchaser CoinJoin, can actually save them satoshis and
improve their privacy at the same time.</p>
<p>AnonGirl waits in the IRC chatroom until she wants to make a purchase.
She announces her intention to spend satoshis and waits until someone
else wants to make a purchase, likely from a different merchant. Then
they combine their inputs the same way as before but set the outputs
to the separate merchant addresses so nobody will be able to figure
out solely from block chain history which one of them bought what from
the merchants.</p>
<p>Since they would've had to pay a transaction fee to make their purchases
anyway, AnonGirl and her co-spenders don't pay anything extra---but
because they reduced overhead by combining multiple transactions, saving
bytes, they may be able to pay a smaller aggregate transaction fee,
saving each one of them a tiny amount of satoshis.</p>
<p><strong>Current Working Implementations:</strong> As of today, in 2018,
<a href="https://github.com/JoinMarket-Org/">JoinMarket</a> and
<a href="http://wasabiwallet.io">Wasabi Wallet</a> are the operational CoinJoin implementations
for Bitcoin.</p>
<p>JoinMarket style CoinJoins differ from the above described scheme by splitting
the participants into two sections: market makers and market takers.
Market makers are publishing their CoinJoin intentions to an IRC
room and waiting for market takers to take their offers. When a taker comes along,
it selects a set of makers and creates a shared transaction with them,
while also paying a small fee. Unlike the above described scheme, this happens automatically.</p>
<p>Wasabi Wallet style CoinJoins are called Chaumian CoinJoins. It employs
a CoinJoin coordinator, where various peers can register. When the pre-defined
number of participants registered, a CoinJoin-round kicks in. In this scheme Chaumian
Blind Signatures are utilized to prevent the coordinator and the peers from learning
which outputs correspond to which inputs. An example for Chaumian CoinJoin is the
following transaction:
<a href="https://www.smartbit.com.au/tx/8fee07b90f26e85e22e87da13e1618cd9eeaf98f3f3774273c9307cd40ff98e8">8fee07b90f26e85e22e87da13e1618cd9eeaf98f3f3774273c9307cd40ff98e8</a></p>
<hr />
<ul>
<li><strong>Kauri original title:</strong> Bitcoin Contract Scripts</li>
<li><strong>Kauri original link:</strong> https://kauri.io/bitcoin-contract-scripts/51a63137f2544b4a97ad1e9dc7eac110/a</li>
<li><strong>Kauri original author:</strong> Kauri Team (@kauri)</li>
<li><strong>Kauri original Publication date:</strong> 2019-06-04</li>
<li><strong>Kauri original tags:</strong> script, bitcoin</li>
<li><strong>Kauri original hash:</strong> QmSMoMo2q2UaqNYBwDxkkBHSi55oVYb7g1wLirYNb3oDEV</li>
<li><strong>Kauri original checkpoint:</strong> QmUP9qZg9vxiTYmDyCRfVzpyYLQbtd6r3GAM7CyqCFhShv</li>
</ul>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../lightning-at-home/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../lightning-at-home/" class="btn btn-xs btn-link">
        Lightning at Home
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../creating-bitcoin-transactions/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../creating-bitcoin-transactions/" class="btn btn-xs btn-link">
        Creating Bitcoin Transactions
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="container-fluid wm-page-content">
      <p>
        <a href="https://github.com/kauri-io/archive/edit/main/docs/collections/Bitcoin/bitcoin-contract-scripts.md"><i class="fa fa-github"></i>
Edit on GitHub</a>
      </p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>